#!/usr/bin/env perl

# This chunk of stuff was generated by App::FatPacker. To find the original
# file's code, look for the end of this BEGIN block or the string 'FATPACK'
BEGIN {
my %fatpacked;

$fatpacked{"Class/Data/Inheritable.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'CLASS_DATA_INHERITABLE';
  package Class::Data::Inheritable;
  
  use strict qw(vars subs);
  use vars qw($VERSION);
  $VERSION = '0.08';
  
  sub mk_classdata {
      my ($declaredclass, $attribute, $data) = @_;
  
      if( ref $declaredclass ) {
          require Carp;
          Carp::croak("mk_classdata() is a class method, not an object method");
      }
  
      my $accessor = sub {
          my $wantclass = ref($_[0]) || $_[0];
  
          return $wantclass->mk_classdata($attribute)->(@_)
            if @_>1 && $wantclass ne $declaredclass;
  
          $data = $_[1] if @_>1;
          return $data;
      };
  
      my $alias = "_${attribute}_accessor";
      *{$declaredclass.'::'.$attribute} = $accessor;
      *{$declaredclass.'::'.$alias}     = $accessor;
  }
  
  1;
  
  __END__
  
  =head1 NAME
  
  Class::Data::Inheritable - Inheritable, overridable class data
  
  =head1 SYNOPSIS
  
    package Stuff;
    use base qw(Class::Data::Inheritable);
  
    # Set up DataFile as inheritable class data.
    Stuff->mk_classdata('DataFile');
  
    # Declare the location of the data file for this class.
    Stuff->DataFile('/etc/stuff/data');
  
    # Or, all in one shot:
    Stuff->mk_classdata(DataFile => '/etc/stuff/data');
  
  =head1 DESCRIPTION
  
  Class::Data::Inheritable is for creating accessor/mutators to class
  data.  That is, if you want to store something about your class as a
  whole (instead of about a single object).  This data is then inherited
  by your subclasses and can be overriden.
  
  For example:
  
    Pere::Ubu->mk_classdata('Suitcase');
  
  will generate the method Suitcase() in the class Pere::Ubu.
  
  This new method can be used to get and set a piece of class data.
  
    Pere::Ubu->Suitcase('Red');
    $suitcase = Pere::Ubu->Suitcase;
  
  The interesting part happens when a class inherits from Pere::Ubu:
  
    package Raygun;
    use base qw(Pere::Ubu);
    
    # Raygun's suitcase is Red.
    $suitcase = Raygun->Suitcase;
  
  Raygun inherits its Suitcase class data from Pere::Ubu.
  
  Inheritance of class data works analogous to method inheritance.  As
  long as Raygun does not "override" its inherited class data (by using
  Suitcase() to set a new value) it will continue to use whatever is set
  in Pere::Ubu and inherit further changes:
  
    # Both Raygun's and Pere::Ubu's suitcases are now Blue
    Pere::Ubu->Suitcase('Blue');
  
  However, should Raygun decide to set its own Suitcase() it has now
  "overridden" Pere::Ubu and is on its own, just like if it had
  overriden a method:
  
    # Raygun has an orange suitcase, Pere::Ubu's is still Blue.
    Raygun->Suitcase('Orange');
  
  Now that Raygun has overridden Pere::Ubu futher changes by Pere::Ubu
  no longer effect Raygun.
  
    # Raygun still has an orange suitcase, but Pere::Ubu is using Samsonite.
    Pere::Ubu->Suitcase('Samsonite');
  
  =head1 Methods
  
  =head2 mk_classdata
  
    Class->mk_classdata($data_accessor_name);
    Class->mk_classdata($data_accessor_name => $value);
  
  This is a class method used to declare new class data accessors.
  A new accessor will be created in the Class using the name from
  $data_accessor_name, and optionally initially setting it to the given
  value.
  
  To facilitate overriding, mk_classdata creates an alias to the
  accessor, _field_accessor().  So Suitcase() would have an alias
  _Suitcase_accessor() that does the exact same thing as Suitcase().
  This is useful if you want to alter the behavior of a single accessor
  yet still get the benefits of inheritable class data.  For example.
  
    sub Suitcase {
        my($self) = shift;
        warn "Fashion tragedy" if @_ and $_[0] eq 'Plaid';
  
        $self->_Suitcase_accessor(@_);
    }
  
  =head1 AUTHOR
  
  Original code by Damian Conway.
  
  Maintained by Michael G Schwern until September 2005.
  
  Now maintained by Tony Bowden.
  
  =head1 BUGS and QUERIES
  
  Please direct all correspondence regarding this module to:
    bug-Class-Data-Inheritable@rt.cpan.org
  
  =head1 COPYRIGHT and LICENSE
  
  Copyright (c) 2000-2005, Damian Conway and Michael G Schwern. 
  All Rights Reserved.  
  
  This module is free software. It may be used, redistributed and/or
  modified under the same terms as Perl itself.
  
  =head1 SEE ALSO
  
  L<perltooc> has a very elaborate discussion of class data in Perl.
  
CLASS_DATA_INHERITABLE

$fatpacked{"Devel/StackTrace.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'DEVEL_STACKTRACE';
  package Devel::StackTrace;
  # git description: v1.34-10-g810fd3f
  
  $Devel::StackTrace::VERSION = '2.00';
  use 5.006;
  
  use strict;
  use warnings;
  
  use Devel::StackTrace::Frame;
  use File::Spec;
  use Scalar::Util qw( blessed );
  
  use overload
      '""'     => \&as_string,
      fallback => 1;
  
  sub new {
      my $class = shift;
      my %p     = @_;
  
      $p{unsafe_ref_capture} = !delete $p{no_refs}
          if exists $p{no_refs};
  
      my $self = bless {
          index  => undef,
          frames => [],
          raw    => [],
          %p,
      }, $class;
  
      $self->_record_caller_data();
  
      return $self;
  }
  
  sub _record_caller_data {
      my $self = shift;
  
      my $filter = $self->{filter_frames_early} && $self->_make_frame_filter();
  
      # We exclude this method by starting at least one frame back.
      my $x = 1 + ( $self->{skip_frames} || 0 );
  
      while (
          my @c
          = $self->{no_args}
          ? caller( $x++ )
          : do {
              package    # the newline keeps dzil from adding a version here
                  DB;
              @DB::args = ();
              caller( $x++ );
          }
          ) {
  
          my @args;
  
          @args = $self->{no_args} ? () : @DB::args;
  
          my $raw = {
              caller => \@c,
              args   => \@args,
          };
  
          next if $filter && !$filter->($raw);
  
          unless ( $self->{unsafe_ref_capture} ) {
              $raw->{args} = [ map { ref $_ ? $self->_ref_to_string($_) : $_ }
                      @{ $raw->{args} } ];
          }
  
          push @{ $self->{raw} }, $raw;
      }
  }
  
  sub _ref_to_string {
      my $self = shift;
      my $ref  = shift;
  
      return overload::AddrRef($ref)
          if blessed $ref && $ref->isa('Exception::Class::Base');
  
      return overload::AddrRef($ref) unless $self->{respect_overload};
  
      local $@;
      local $SIG{__DIE__};
  
      my $str = eval { $ref . '' };
  
      return $@ ? overload::AddrRef($ref) : $str;
  }
  
  sub _make_frames {
      my $self = shift;
  
      my $filter = !$self->{filter_frames_early} && $self->_make_frame_filter();
  
      my $raw = delete $self->{raw};
      for my $r ( @{$raw} ) {
          next if $filter && !$filter->($r);
  
          $self->_add_frame( $r->{caller}, $r->{args} );
      }
  }
  
  my $default_filter = sub { 1 };
  
  sub _make_frame_filter {
      my $self = shift;
  
      my ( @i_pack_re, %i_class );
      if ( $self->{ignore_package} ) {
          local $@;
          local $SIG{__DIE__};
  
          $self->{ignore_package} = [ $self->{ignore_package} ]
              unless eval { @{ $self->{ignore_package} } };
  
          @i_pack_re
              = map { ref $_ ? $_ : qr/^\Q$_\E$/ } @{ $self->{ignore_package} };
      }
  
      my $p = __PACKAGE__;
      push @i_pack_re, qr/^\Q$p\E$/;
  
      if ( $self->{ignore_class} ) {
          $self->{ignore_class} = [ $self->{ignore_class} ]
              unless ref $self->{ignore_class};
          %i_class = map { $_ => 1 } @{ $self->{ignore_class} };
      }
  
      my $user_filter = $self->{frame_filter};
  
      return sub {
          return 0 if grep { $_[0]{caller}[0] =~ /$_/ } @i_pack_re;
          return 0 if grep { $_[0]{caller}[0]->isa($_) } keys %i_class;
  
          if ($user_filter) {
              return $user_filter->( $_[0] );
          }
  
          return 1;
      };
  }
  
  sub _add_frame {
      my $self = shift;
      my $c    = shift;
      my $p    = shift;
  
      # eval and is_require are only returned when applicable under 5.00503.
      push @$c, ( undef, undef ) if scalar @$c == 6;
  
      push @{ $self->{frames} },
          Devel::StackTrace::Frame->new(
          $c,
          $p,
          $self->{respect_overload},
          $self->{max_arg_length},
          $self->{message},
          $self->{indent}
          );
  }
  
  sub next_frame {
      my $self = shift;
  
      # reset to top if necessary.
      $self->{index} = -1 unless defined $self->{index};
  
      my @f = $self->frames();
      if ( defined $f[ $self->{index} + 1 ] ) {
          return $f[ ++$self->{index} ];
      }
      else {
          $self->{index} = undef;
          return undef;
      }
  }
  
  sub prev_frame {
      my $self = shift;
  
      my @f = $self->frames();
  
      # reset to top if necessary.
      $self->{index} = scalar @f unless defined $self->{index};
  
      if ( defined $f[ $self->{index} - 1 ] && $self->{index} >= 1 ) {
          return $f[ --$self->{index} ];
      }
      else {
          $self->{index} = undef;
          return undef;
      }
  }
  
  sub reset_pointer {
      my $self = shift;
  
      $self->{index} = undef;
  }
  
  sub frames {
      my $self = shift;
  
      if (@_) {
          die
              "Devel::StackTrace->frames() can only take Devel::StackTrace::Frame args\n"
              if grep { !$_->isa('Devel::StackTrace::Frame') } @_;
  
          $self->{frames} = \@_;
      }
      else {
          $self->_make_frames() if $self->{raw};
      }
  
      return @{ $self->{frames} };
  }
  
  sub frame {
      my $self = shift;
      my $i    = shift;
  
      return unless defined $i;
  
      return ( $self->frames() )[$i];
  }
  
  sub frame_count {
      my $self = shift;
  
      return scalar( $self->frames() );
  }
  
  sub as_string {
      my $self = shift;
      my $p    = shift;
  
      my $st    = '';
      my $first = 1;
      foreach my $f ( $self->frames() ) {
          $st .= $f->as_string( $first, $p ) . "\n";
          $first = 0;
      }
  
      return $st;
  }
  
  {
      package    # hide from PAUSE
          Devel::StackTraceFrame;
  
      our @ISA = 'Devel::StackTrace::Frame';
  }
  
  1;
  
  # ABSTRACT: An object representing a stack trace
  
  __END__
  
  =pod
  
  =head1 NAME
  
  Devel::StackTrace - An object representing a stack trace
  
  =head1 VERSION
  
  version 2.00
  
  =head1 SYNOPSIS
  
    use Devel::StackTrace;
  
    my $trace = Devel::StackTrace->new();
  
    print $trace->as_string(); # like carp
  
    # from top (most recent) of stack to bottom.
    while ( my $frame = $trace->next_frame() ) {
        print "Has args\n" if $frame->hasargs();
    }
  
    # from bottom (least recent) of stack to top.
    while ( my $frame = $trace->prev_frame() ) {
        print "Sub: ", $frame->subroutine(), "\n";
    }
  
  =head1 DESCRIPTION
  
  The C<Devel::StackTrace> module contains two classes, C,Devel::StackTrace> and
  L<Devel::StackTrace::Frame>. These objects encapsulate the information that
  can retrieved via Perl's C<caller()> function, as well as providing a simple
  interface to this data.
  
  The C<Devel::StackTrace> object contains a set of C<Devel::StackTrace::Frame>
  objects, one for each level of the stack. The frames contain all the data
  available from C<caller()>.
  
  This code was created to support my L<Exception::Class::Base> class (part of
  L<Exception::Class>) but may be useful in other contexts.
  
  =encoding UTF-8
  
  =head1 'TOP' AND 'BOTTOM' OF THE STACK
  
  When describing the methods of the trace object, I use the words 'top' and
  'bottom'. In this context, the 'top' frame on the stack is the most recent
  frame and the 'bottom' is the least recent.
  
  Here's an example:
  
    foo();  # bottom frame is here
  
    sub foo {
       bar();
    }
  
    sub bar {
       Devel::StackTrace->new();  # top frame is here.
    }
  
  =head1 METHODS
  
  This class provide the following methods:
  
  =head2 Devel::StackTrace->new(%named_params)
  
  Returns a new Devel::StackTrace object.
  
  Takes the following parameters:
  
  =over 4
  
  =item * frame_filter => $sub
  
  By default, Devel::StackTrace will include all stack frames before the
  call to its constructor.
  
  However, you may want to filter out some frames with more granularity
  than 'ignore_package' or 'ignore_class' allow.
  
  You can provide a subroutine which is called with the raw frame data
  for each frame. This is a hash reference with two keys, "caller", and
  "args", both of which are array references. The "caller" key is the
  raw data as returned by Perl's C<caller()> function, and the "args"
  key are the subroutine arguments found in C<@DB::args>.
  
  The filter should return true if the frame should be included, or
  false if it should be skipped.
  
  =item * filter_frames_early => $boolean
  
  If this parameter is true, C<frame_filter> will be called as soon as the
  stacktrace is created, and before refs are stringified (if
  C<unsafe_ref_capture> is not set), rather than being filtered lazily when
  L<Devel::StackTrace::Frame> objects are first needed.
  
  This is useful if you want to filter based on the frame's arguments and want
  to be able to examine object properties, for example.
  
  =item * ignore_package => $package_name OR \@package_names
  
  Any frames where the package is one of these packages will not be on
  the stack.
  
  =item * ignore_class => $package_name OR \@package_names
  
  Any frames where the package is a subclass of one of these packages
  (or is the same package) will not be on the stack.
  
  Devel::StackTrace internally adds itself to the 'ignore_package'
  parameter, meaning that the Devel::StackTrace package is B<ALWAYS>
  ignored. However, if you create a subclass of Devel::StackTrace it
  will not be ignored.
  
  =item * skip_frames => $integer
  
  This will cause this number of stack frames to be excluded from top of the
  stack trace. This prevents the frames from being captured at all, and applies
  before the C<frame_filter>, C<ignore_package>, or C<ignore_class> options,
  even with C<filter_frames_early>.
  
  =item * unsafe_ref_capture => $boolean
  
  If this parameter is true, then Devel::StackTrace will store
  references internally when generating stacktrace frames.
  
  B<This option is very dangerous, and should never be used with exception
  objects>. Using this option will keep any objects or references alive past
  their normal lifetime, until the stack trace object goes out of scope. It can
  keep objects alive even after their C<DESTROY> sub is called, resulting it it
  being called multiple times on the same object.
  
  If not set, Devel::StackTrace replaces any references with their stringified
  representation.
  
  =item * no_args => $boolean
  
  If this parameter is true, then Devel::StackTrace will not store caller
  arguments in stack trace frames at all.
  
  =item * respect_overload => $boolean
  
  By default, Devel::StackTrace will call C<overload::AddrRef()> to get
  the underlying string representation of an object, instead of
  respecting the object's stringification overloading. If you would
  prefer to see the overloaded representation of objects in stack
  traces, then set this parameter to true.
  
  =item * max_arg_length => $integer
  
  By default, Devel::StackTrace will display the entire argument for each
  subroutine call. Setting this parameter causes truncates each subroutine
  argument's string representation if it is longer than this number of
  characters.
  
  =item * message => $string
  
  By default, Devel::StackTrace will use 'Trace begun' as the message for the
  first stack frame when you call C<as_string>. You can supply an alternative
  message using this option.
  
  =item * indent => $boolean
  
  If this parameter is true, each stack frame after the first will start with a
  tab character, just like C<Carp::confess()>.
  
  =back
  
  =head2 $trace->next_frame()
  
  Returns the next L<Devel::StackTrace::Frame> object on the stack, going
  down. If this method hasn't been called before it returns the first frame. It
  returns C<undef> when it reaches the bottom of the stack and then resets its
  pointer so the next call to C<< $trace->next_frame() >> or C<<
  $trace->prev_frame() >> will work properly.
  
  =head2 $trace->prev_frame()
  
  Returns the next L<Devel::StackTrace::Frame> object on the stack, going up. If
  this method hasn't been called before it returns the last frame. It returns
  undef when it reaches the top of the stack and then resets its pointer so the
  next call to C<< $trace->next_frame() >> or C<< $trace->prev_frame() >> will
  work properly.
  
  =head2 $trace->reset_pointer
  
  Resets the pointer so that the next call to C<< $trace->next_frame() >> or C<<
  $trace->prev_frame() >> will start at the top or bottom of the stack, as
  appropriate.
  
  =head2 $trace->frames()
  
  When this method is called with no arguments, it returns a list of
  L<Devel::StackTrace::Frame> objects. They are returned in order from top (most
  recent) to bottom.
  
  This method can also be used to set the object's frames if you pass it a list
  of L<Devel::StackTrace::Frame> objects.
  
  This is useful if you want to filter the list of frames in ways that are more
  complex than can be handled by the C<< $trace->filter_frames() >> method:
  
    $stacktrace->frames( my_filter( $stacktrace->frames() ) );
  
  =head2 $trace->frame($index)
  
  Given an index, this method returns the relevant frame, or undef if there is
  no frame at that index. The index is exactly like a Perl array. The first
  frame is 0 and negative indexes are allowed.
  
  =head2 $trace->frame_count()
  
  Returns the number of frames in the trace object.
  
  =head2 $trace->as_string(\%p)
  
  Calls C<< $frame->as_string() >> on each frame from top to bottom, producing
  output quite similar to the Carp module's cluck/confess methods.
  
  The optional C<\%p> parameter only has one option. The C<max_arg_length>
  parameter truncates each subroutine argument's string representation if it is
  longer than this number of characters.
  
  =head1 SUPPORT
  
  Please submit bugs to the CPAN RT system at
  http://rt.cpan.org/NoAuth/ReportBug.html?Queue=Devel%3A%3AStackTrace
  or via email at bug-devel-stacktrace@rt.cpan.org.
  
  =head1 AUTHOR
  
  Dave Rolsky <autarch@urth.org>
  
  =head1 CONTRIBUTORS
  
  =for stopwords Dagfinn Ilmari Mannsåker David Cantrell Graham Knop Ricardo Signes
  
  =over 4
  
  =item *
  
  Dagfinn Ilmari Mannsåker <ilmari@ilmari.org>
  
  =item *
  
  David Cantrell <david@cantrell.org.uk>
  
  =item *
  
  Graham Knop <haarg@haarg.org>
  
  =item *
  
  Ricardo Signes <rjbs@cpan.org>
  
  =back
  
  =head1 COPYRIGHT AND LICENSE
  
  This software is Copyright (c) 2000 - 2014 by David Rolsky.
  
  This is free software, licensed under:
  
    The Artistic License 2.0 (GPL Compatible)
  
  =cut
DEVEL_STACKTRACE

$fatpacked{"Devel/StackTrace/Frame.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'DEVEL_STACKTRACE_FRAME';
  package Devel::StackTrace::Frame;
  $Devel::StackTrace::Frame::VERSION = '2.00';
  use strict;
  use warnings;
  
  # Create accessor routines
  BEGIN {
      no strict 'refs';
      foreach my $f (
          qw( package filename line subroutine hasargs
          wantarray evaltext is_require hints bitmask args )
          ) {
          next if $f eq 'args';
          *{$f} = sub { my $s = shift; return $s->{$f} };
      }
  }
  
  {
      my @fields = (
          qw( package filename line subroutine hasargs wantarray
              evaltext is_require hints bitmask )
      );
  
      sub new {
          my $proto = shift;
          my $class = ref $proto || $proto;
  
          my $self = bless {}, $class;
  
          @{$self}{@fields} = @{ shift() };
  
          # fixup unix-style paths on win32
          $self->{filename} = File::Spec->canonpath( $self->{filename} );
  
          $self->{args} = shift;
  
          $self->{respect_overload} = shift;
  
          $self->{max_arg_length} = shift;
  
          $self->{message} = shift;
  
          $self->{indent} = shift;
  
          return $self;
      }
  }
  
  sub args {
      my $self = shift;
  
      return @{ $self->{args} };
  }
  
  sub as_string {
      my $self  = shift;
      my $first = shift;
      my $p     = shift;
  
      my $sub = $self->subroutine;
  
      # This code stolen straight from Carp.pm and then tweaked.  All
      # errors are probably my fault  -dave
      if ($first) {
          $sub
              = defined $self->{message}
              ? $self->{message}
              : 'Trace begun';
      }
      else {
  
          # Build a string, $sub, which names the sub-routine called.
          # This may also be "require ...", "eval '...' or "eval {...}"
          if ( my $eval = $self->evaltext ) {
              if ( $self->is_require ) {
                  $sub = "require $eval";
              }
              else {
                  $eval =~ s/([\\\'])/\\$1/g;
                  $sub = "eval '$eval'";
              }
          }
          elsif ( $sub eq '(eval)' ) {
              $sub = 'eval {...}';
          }
  
          # if there are any arguments in the sub-routine call, format
          # them according to the format variables defined earlier in
          # this file and join them onto the $sub sub-routine string
          #
          # We copy them because they're going to be modified.
          #
          if ( my @a = $self->args ) {
              for (@a) {
  
                  # set args to the string "undef" if undefined
                  $_ = "undef", next unless defined $_;
  
                  # hack!
                  $_ = $self->Devel::StackTrace::_ref_to_string($_)
                      if ref $_;
  
                  local $SIG{__DIE__};
                  local $@;
  
                  eval {
                      my $max_arg_length
                          = exists $p->{max_arg_length}
                          ? $p->{max_arg_length}
                          : $self->{max_arg_length};
  
                      if ( $max_arg_length
                          && length $_ > $max_arg_length ) {
                          substr( $_, $max_arg_length ) = '...';
                      }
  
                      s/'/\\'/g;
  
                      # 'quote' arg unless it looks like a number
                      $_ = "'$_'" unless /^-?[\d.]+$/;
  
                      # print control/high ASCII chars as 'M-<char>' or '^<char>'
                      s/([\200-\377])/sprintf("M-%c",ord($1)&0177)/eg;
                      s/([\0-\37\177])/sprintf("^%c",ord($1)^64)/eg;
                  };
  
                  if ( my $e = $@ ) {
                      $_ = $e =~ /malformed utf-8/i ? '(bad utf-8)' : '?';
                  }
              }
  
              # append ('all', 'the', 'arguments') to the $sub string
              $sub .= '(' . join( ', ', @a ) . ')';
              $sub .= ' called';
          }
      }
  
      # If the user opted into indentation (a la Carp::confess), pre-add a tab
      my $tab = $self->{indent} && !$first ? "\t" : q{};
  
      return "${tab}$sub at " . $self->filename . ' line ' . $self->line;
  }
  
  1;
  
  # ABSTRACT: A single frame in a stack trace
  
  __END__
  
  =pod
  
  =head1 NAME
  
  Devel::StackTrace::Frame - A single frame in a stack trace
  
  =head1 VERSION
  
  version 2.00
  
  =head1 DESCRIPTION
  
  See L<Devel::StackTrace> for details.
  
  =for Pod::Coverage new
  
  =head1 METHODS
  
  See Perl's C<caller()> documentation for more information on what these
  methods return.
  
  =head2 $frame->package()
  
  =head2 $frame->filename()
  
  =head2 $frame->line()
  
  =head2 $frame->subroutine()
  
  =head2 $frame->hasargs()
  
  =head2 $frame->wantarray()
  
  =head2 $frame->evaltext()
  
  Returns undef if the frame was not part of an eval.
  
  =head2 $frame->is_require()
  
  Returns undef if the frame was not part of a require.
  
  =head2 $frame->args()
  
  Returns the arguments passed to the frame.  Note that any arguments that are
  references are returned as references, not copies.
  
  =head2 $frame->hints()
  
  =head2 $frame->bitmask()
  
  =head2 $frame->as_string()
  
  Returns a string containing a description of the frame.
  
  =head1 AUTHOR
  
  Dave Rolsky <autarch@urth.org>
  
  =head1 COPYRIGHT AND LICENSE
  
  This software is Copyright (c) 2000 - 2014 by David Rolsky.
  
  This is free software, licensed under:
  
    The Artistic License 2.0 (GPL Compatible)
  
  =cut
DEVEL_STACKTRACE_FRAME

$fatpacked{"Exception/Class.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'EXCEPTION_CLASS';
  package Exception::Class;
  # git description: v1.38-8-gbef365d
  
  $Exception::Class::VERSION = '1.39';
  use 5.008001;
  
  use strict;
  
  use Exception::Class::Base;
  use Scalar::Util qw(blessed);
  
  our $BASE_EXC_CLASS;
  BEGIN { $BASE_EXC_CLASS ||= 'Exception::Class::Base'; }
  
  our %CLASSES;
  
  sub import {
      my $class = shift;
  
      local $Exception::Class::Caller = caller();
  
      my %c;
  
      my %needs_parent;
      while ( my $subclass = shift ) {
          my $def = ref $_[0] ? shift : {};
          $def->{isa}
              = $def->{isa}
              ? ( ref $def->{isa} ? $def->{isa} : [ $def->{isa} ] )
              : [];
  
          $c{$subclass} = $def;
      }
  
      # We need to sort by length because if we check for keys in the
      # Foo::Bar:: stash, this creates a "Bar::" key in the Foo:: stash!
  MAKE_CLASSES:
      foreach my $subclass ( sort { length $a <=> length $b } keys %c ) {
          my $def = $c{$subclass};
  
          # We already made this one.
          next if $CLASSES{$subclass};
  
          {
              no strict 'refs';
              foreach my $parent ( @{ $def->{isa} } ) {
                  unless ( keys %{"$parent\::"} ) {
                      $needs_parent{$subclass} = {
                          parents => $def->{isa},
                          def     => $def
                      };
                      next MAKE_CLASSES;
                  }
              }
          }
  
          $class->_make_subclass(
              subclass => $subclass,
              def      => $def || {},
          );
      }
  
      foreach my $subclass ( keys %needs_parent ) {
  
          # This will be used to spot circular references.
          my %seen;
          $class->_make_parents( \%needs_parent, $subclass, \%seen );
      }
  }
  
  sub _make_parents {
      my $class    = shift;
      my $needs    = shift;
      my $subclass = shift;
      my $seen     = shift;
      my $child    = shift;    # Just for error messages.
  
      no strict 'refs';
  
      # What if someone makes a typo in specifying their 'isa' param?
      # This should catch it. Either it's been made because it didn't
      # have missing parents OR it's in our hash as needing a parent.
      # If neither of these is true then the _only_ place it is
      # mentioned is in the 'isa' param for some other class, which is
      # not a good enough reason to make a new class.
      die
          "Class $subclass appears to be a typo as it is only specified in the 'isa' param for $child\n"
          unless exists $needs->{$subclass}
          || $CLASSES{$subclass}
          || keys %{"$subclass\::"};
  
      foreach my $c ( @{ $needs->{$subclass}{parents} } ) {
  
          # It's been made
          next if $CLASSES{$c} || keys %{"$c\::"};
  
          die "There appears to be some circularity involving $subclass\n"
              if $seen->{$subclass};
  
          $seen->{$subclass} = 1;
  
          $class->_make_parents( $needs, $c, $seen, $subclass );
      }
  
      return if $CLASSES{$subclass} || keys %{"$subclass\::"};
  
      $class->_make_subclass(
          subclass => $subclass,
          def      => $needs->{$subclass}{def}
      );
  }
  
  sub _make_subclass {
      my $class = shift;
      my %p     = @_;
  
      my $subclass = $p{subclass};
      my $def      = $p{def};
  
      my $isa;
      if ( $def->{isa} ) {
          $isa = ref $def->{isa} ? join ' ', @{ $def->{isa} } : $def->{isa};
      }
      $isa ||= $BASE_EXC_CLASS;
  
      my $version_name = 'VERSION';
  
      my $code = <<"EOPERL";
  package $subclass;
  
  use base qw($isa);
  
  our \$$version_name = '1.1';
  
  1;
  
  EOPERL
  
      if ( $def->{description} ) {
          ( my $desc = $def->{description} ) =~ s/([\\\'])/\\$1/g;
          $code .= <<"EOPERL";
  sub description
  {
      return '$desc';
  }
  EOPERL
      }
  
      my @fields;
      if ( my $fields = $def->{fields} ) {
          @fields = UNIVERSAL::isa( $fields, 'ARRAY' ) ? @$fields : $fields;
  
          $code
              .= "sub Fields { return (\$_[0]->SUPER::Fields, "
              . join( ", ", map { "'$_'" } @fields )
              . ") }\n\n";
  
          foreach my $field (@fields) {
              $code .= sprintf( "sub %s { \$_[0]->{%s} }\n", $field, $field );
          }
      }
  
      if ( my $alias = $def->{alias} ) {
          die "Cannot make alias without caller"
              unless defined $Exception::Class::Caller;
  
          no strict 'refs';
          *{"$Exception::Class::Caller\::$alias"}
              = sub { $subclass->throw(@_) };
      }
  
      if ( my $defaults = $def->{defaults} ) {
          $code
              .= "sub _defaults { return shift->SUPER::_defaults, our \%_DEFAULTS }\n";
          no strict 'refs';
          *{"$subclass\::_DEFAULTS"} = {%$defaults};
      }
  
      eval $code;
  
      die $@ if $@;
  
      $CLASSES{$subclass} = 1;
  }
  
  sub caught {
      my $e = $@;
  
      return $e unless $_[1];
  
      return unless blessed($e) && $e->isa( $_[1] );
      return $e;
  }
  
  sub Classes { sort keys %Exception::Class::CLASSES }
  
  1;
  
  # ABSTRACT: A module that allows you to declare real exception classes in Perl
  
  __END__
  
  =pod
  
  =head1 NAME
  
  Exception::Class - A module that allows you to declare real exception classes in Perl
  
  =head1 VERSION
  
  version 1.39
  
  =head1 SYNOPSIS
  
    use Exception::Class (
        'MyException',
  
        'AnotherException' => { isa => 'MyException' },
  
        'YetAnotherException' => {
            isa         => 'AnotherException',
            description => 'These exceptions are related to IPC'
        },
  
        'ExceptionWithFields' => {
            isa    => 'YetAnotherException',
            fields => [ 'grandiosity', 'quixotic' ],
            alias  => 'throw_fields',
        },
    );
    use Scalar::Util qw( blessed );
    use Try::Tiny;
  
    try {
        MyException->throw( error => 'I feel funny.' );
    }
    catch {
        die $_ unless blessed $_ && $_->can('rethrow');
  
        if ( $_->isa('Exception::Class') ) {
            warn $_->error, "\n", $_->trace->as_string, "\n";
            warn join ' ', $_->euid, $_->egid, $_->uid, $_->gid, $_->pid, $_->time;
  
            exit;
        }
        elsif ( $_->isa('ExceptionWithFields') ) {
            if ( $_->quixotic ) {
                handle_quixotic_exception();
            }
            else {
                handle_non_quixotic_exception();
            }
        }
        else {
            $_->rethrow;
        }
    };
  
    # without Try::Tiny
  
    eval { ... };
    if ( my $e = Exception::Class->caught() ) { ... }
  
    # use an alias - without parens subroutine name is checked at
    # compile time
    throw_fields error => "No strawberry", grandiosity => "quite a bit";
  
  =head1 DESCRIPTION
  
  B<RECOMMENDATION 1>: If you are writing modern Perl code with L<Moose> or
  L<Moo> I highly recommend using L<Throwable> instead of this module.
  
  B<RECOMMENDATION 2>: Whether or not you use L<Throwable>, you should use
  L<Try::Tiny>.
  
  Exception::Class allows you to declare exception hierarchies in your
  modules in a "Java-esque" manner.
  
  It features a simple interface allowing programmers to 'declare'
  exception classes at compile time. It also has a base exception
  class, L<Exception::Class::Base>, that can be easily extended.
  
  It is designed to make structured exception handling simpler and
  better by encouraging people to use hierarchies of exceptions in their
  applications, as opposed to a single catch-all exception class.
  
  This module does not implement any try/catch syntax. Please see the
  "OTHER EXCEPTION MODULES (try/catch syntax)" section for more
  information on how to get this syntax.
  
  You will also want to look at the documentation for
  L<Exception::Class::Base>, which is the default base class for all
  exception objects created by this module.
  
  =for Pod::Coverage     Classes
      caught
  
  =head1 DECLARING EXCEPTION CLASSES
  
  Importing C<Exception::Class> allows you to automagically create
  L<Exception::Class::Base> subclasses. You can also create subclasses
  via the traditional means of defining your own subclass with C<@ISA>.
  These two methods may be easily combined, so that you could subclass
  an exception class defined via the automagic import, if you desired
  this.
  
  The syntax for the magic declarations is as follows:
  
  'MANDATORY CLASS NAME' => \%optional_hashref
  
  The hashref may contain the following options:
  
  =over 4
  
  =item * isa
  
  This is the class's parent class. If this isn't provided then the
  class name in C<$Exception::Class::BASE_EXC_CLASS> is assumed to be
  the parent (see below).
  
  This parameter lets you create arbitrarily deep class hierarchies.
  This can be any other L<Exception::Class::Base> subclass in your
  declaration I<or> a subclass loaded from a module.
  
  To change the default exception class you will need to change the
  value of C<$Exception::Class::BASE_EXC_CLASS> I<before> calling
  C<import()>. To do this simply do something like this:
  
    BEGIN { $Exception::Class::BASE_EXC_CLASS = 'SomeExceptionClass'; }
  
  If anyone can come up with a more elegant way to do this please let me
  know.
  
  CAVEAT: If you want to automagically subclass an
  L<Exception::Class::Base> subclass loaded from a file, then you
  I<must> compile the class (via use or require or some other magic)
  I<before> you import C<Exception::Class> or you'll get a compile time
  error.
  
  =item * fields
  
  This allows you to define additional attributes for your exception
  class. Any field you define can be passed to the C<throw()> or
  C<new()> methods as additional parameters for the constructor. In
  addition, your exception object will have an accessor method for the
  fields you define.
  
  This parameter can be either a scalar (for a single field) or an array
  reference if you need to define multiple fields.
  
  Fields will be inherited by subclasses.
  
  =item * alias
  
  Specifying an alias causes this class to create a subroutine of the
  specified name in the I<caller's> namespace. Calling this subroutine
  is equivalent to calling C<< <class>->throw(@_) >> for the given
  exception class.
  
  Besides convenience, using aliases also allows for additional compile
  time checking. If the alias is called I<without parentheses>, as in
  C<throw_fields "an error occurred">, then Perl checks for the
  existence of the C<throw_fields()> subroutine at compile time. If
  instead you do C<< ExceptionWithFields->throw(...) >>, then Perl
  checks the class name at runtime, meaning that typos may sneak
  through.
  
  =item * description
  
  Each exception class has a description method that returns a fixed
  string. This should describe the exception I<class> (as opposed to
  any particular exception object). This may be useful for debugging if
  you start catching exceptions you weren't expecting (particularly if
  someone forgot to document them) and you don't understand the error
  messages.
  
  =back
  
  The C<Exception::Class> magic attempts to detect circular class
  hierarchies and will die if it finds one. It also detects missing
  links in a chain, for example if you declare Bar to be a subclass of
  Foo and never declare Foo.
  
  =head1 L<Try::Tiny>
  
  If you are interested in adding try/catch/finally syntactic sugar to your code
  then I recommend you check out L<Try::Tiny>. This is a great module that helps
  you ignore some of the weirdness with C<eval> and C<$@>. Here's an example of
  how the two modules work together:
  
    use Exception::Class ( 'My::Exception' );
    use Scalar::Util qw( blessed );
    use Try::Tiny;
  
    try {
        might_throw();
    }
    catch {
        if ( blessed $_ && $_->isa('My::Exception') ) {
            handle_it();
        }
        else {
            die $_;
        }
    };
  
  Note that you B<cannot> use C<< Exception::Class->caught() >> with
  L<Try::Tiny>.
  
  =head1 Catching Exceptions Without L<Try::Tiny>
  
  C<Exception::Class> provides some syntactic sugar for catching
  exceptions in a safe manner:
  
    eval {...};
  
    if ( my $e = Exception::Class->caught('My::Error') ) {
        cleanup();
        do_something_with_exception($e);
    }
  
  The C<caught()> method takes a class name and returns an exception
  object if the last thrown exception is of the given class, or a
  subclass of that class. If it is not given any arguments, it simply
  returns C<$@>.
  
  You should B<always> make a copy of the exception object, rather than
  using C<$@> directly. This is necessary because if your C<cleanup()>
  function uses C<eval>, or calls something which uses it, then C<$@> is
  overwritten. Copying the exception preserves it for the call to
  C<do_something_with_exception()>.
  
  Exception objects also provide a caught method so you can write:
  
    if ( my $e = My::Error->caught() ) {
        cleanup();
        do_something_with_exception($e);
    }
  
  =head2 Uncatchable Exceptions
  
  Internally, the C<caught()> method will call C<isa()> on the exception
  object. You could make an exception "uncatchable" by overriding
  C<isa()> in that class like this:
  
   package Exception::Uncatchable;
  
   sub isa { shift->rethrow }
  
  Of course, this only works if you always call C<< Exception::Class->caught()
  >> after an C<eval>.
  
  =head1 USAGE RECOMMENDATION
  
  If you're creating a complex system that throws lots of different
  types of exceptions, consider putting all the exception declarations
  in one place. For an app called Foo you might make a
  C<Foo::Exceptions> module and use that in all your code. This module
  could just contain the code to make C<Exception::Class> do its
  automagic class creation. Doing this allows you to more easily see
  what exceptions you have, and makes it easier to keep track of them.
  
  This might look something like this:
  
    package Foo::Bar::Exceptions;
  
    use Exception::Class (
        Foo::Bar::Exception::Senses =>
            { description => 'sense-related exception' },
  
        Foo::Bar::Exception::Smell => {
            isa         => 'Foo::Bar::Exception::Senses',
            fields      => 'odor',
            description => 'stinky!'
        },
  
        Foo::Bar::Exception::Taste => {
            isa         => 'Foo::Bar::Exception::Senses',
            fields      => [ 'taste', 'bitterness' ],
            description => 'like, gag me with a spoon!'
        },
  
        ...
    );
  
  You may want to create a real module to subclass
  L<Exception::Class::Base> as well, particularly if you want your
  exceptions to have more methods.
  
  =head2 Subclassing Exception::Class::Base
  
  As part of your usage of C<Exception::Class>, you may want to create
  your own base exception class which subclasses
  L<Exception::Class::Base>. You should feel free to subclass any of
  the methods documented above. For example, you may want to subclass
  C<new()> to add additional information to your exception objects.
  
  =head1 Exception::Class FUNCTIONS
  
  The C<Exception::Class> method offers one function, C<Classes()>,
  which is not exported. This method returns a list of the classes that
  have been created by calling the C<Exception::Class> import() method.
  Note that this is I<all> the subclasses that have been created, so it
  may include subclasses created by things like CPAN modules, etc. Also
  note that if you simply define a subclass via the normal Perl method
  of setting C<@ISA> or C<use base>, then your subclass will not be
  included.
  
  =head1 SUPPORT
  
  Please submit bugs to the CPAN RT system at
  http://rt.cpan.org/NoAuth/ReportBug.html?Queue=Exception%3A%3AClass or
  via email at bug-exception-class@rt.cpan.org.
  
  =head1 DONATIONS
  
  If you'd like to thank me for the work I've done on this module,
  please consider making a "donation" to me via PayPal. I spend a lot of
  free time creating free software, and would appreciate any support
  you'd care to offer.
  
  Please note that B<I am not suggesting that you must do this> in order
  for me to continue working on this particular software. I will
  continue to do so, inasmuch as I have in the past, for as long as it
  interests me.
  
  Similarly, a donation made in this way will probably not make me work
  on this software much more, unless I get so many donations that I can
  consider working on free software full time, which seems unlikely at
  best.
  
  To donate, log into PayPal and send money to autarch@urth.org or use
  the button on this page:
  L<http://www.urth.org/~autarch/fs-donation.html>
  
  =head1 AUTHOR
  
  Dave Rolsky <autarch@urth.org>
  
  =head1 CONTRIBUTOR
  
  =for stopwords Ricardo Signes
  
  Ricardo Signes <rjbs@cpan.org>
  
  =head1 COPYRIGHT AND LICENSE
  
  This software is copyright (c) 2014 by David Rolsky.
  
  This is free software; you can redistribute it and/or modify it under
  the same terms as the Perl 5 programming language system itself.
  
  =cut
EXCEPTION_CLASS

$fatpacked{"Exception/Class/Base.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'EXCEPTION_CLASS_BASE';
  package Exception::Class::Base;
  $Exception::Class::Base::VERSION = '1.39';
  use strict;
  use warnings;
  
  use Class::Data::Inheritable 0.02;
  use Devel::StackTrace 2.00;
  use Scalar::Util qw( blessed );
  
  use base qw(Class::Data::Inheritable);
  
  BEGIN {
      __PACKAGE__->mk_classdata('Trace');
      __PACKAGE__->mk_classdata('UnsafeRefCapture');
  
      __PACKAGE__->mk_classdata('NoContextInfo');
      __PACKAGE__->NoContextInfo(0);
  
      __PACKAGE__->mk_classdata('RespectOverload');
      __PACKAGE__->RespectOverload(0);
  
      __PACKAGE__->mk_classdata('MaxArgLength');
      __PACKAGE__->MaxArgLength(0);
  
      sub NoRefs {
          my $self = shift;
          if (@_) {
              my $val = shift;
              return $self->UnsafeRefCapture(!$val);
          }
          else {
              return $self->UnsafeRefCapture();
          }
      }
  
      sub Fields { () }
  }
  
  use overload
  
      # an exception is always true
      bool => sub { 1 }, '""' => 'as_string', fallback => 1;
  
  # Create accessor routines
  BEGIN {
      my @fields = qw( message pid uid euid gid egid time trace );
  
      foreach my $f (@fields) {
          my $sub = sub { my $s = shift; return $s->{$f}; };
  
          no strict 'refs';
          *{$f} = $sub;
      }
      *error = \&message;
  
      my %trace_fields = (
          package => 'package',
          file    => 'filename',
          line    => 'line',
      );
  
      while ( my ( $f, $m ) = each %trace_fields ) {
          my $sub = sub {
              my $s = shift;
              return $s->{$f} if exists $s->{$f};
  
              my $frame = $s->trace->frame(0);
  
              return $s->{$f} = $frame ? $frame->$m() : undef;
          };
          no strict 'refs';
          *{$f} = $sub;
      }
  }
  
  sub Classes { Exception::Class::Classes() }
  
  sub throw {
      my $proto = shift;
  
      $proto->rethrow if ref $proto;
  
      die $proto->new(@_);
  }
  
  sub rethrow {
      my $self = shift;
  
      die $self;
  }
  
  sub new {
      my $proto = shift;
      my $class = ref $proto || $proto;
  
      my $self = bless {}, $class;
  
      $self->_initialize(@_);
  
      return $self;
  }
  
  sub _initialize {
      my $self = shift;
      my %p = @_ == 1 ? ( error => $_[0] ) : @_;
  
      $self->{message} = $p{message} || $p{error} || '';
  
      $self->{show_trace} = $p{show_trace} if exists $p{show_trace};
  
      if ( $self->NoContextInfo() ) {
          $self->{show_trace} = 0;
          $self->{package} = $self->{file} = $self->{line} = undef;
      }
      else {
          # CORE::time is important to fix an error with some versions of
          # Perl
          $self->{time} = CORE::time();
          $self->{pid}  = $$;
          $self->{uid}  = $<;
          $self->{euid} = $>;
          $self->{gid}  = $(;
          $self->{egid} = $);
  
          my @ignore_class   = (__PACKAGE__);
          my @ignore_package = 'Exception::Class';
  
          if ( my $i = delete $p{ignore_class} ) {
              push @ignore_class, ( ref($i) eq 'ARRAY' ? @$i : $i );
          }
  
          if ( my $i = delete $p{ignore_package} ) {
              push @ignore_package, ( ref($i) eq 'ARRAY' ? @$i : $i );
          }
  
          $self->{trace} = Devel::StackTrace->new(
              ignore_class       => \@ignore_class,
              ignore_package     => \@ignore_package,
              unsafe_ref_capture => $self->UnsafeRefCapture,
              respect_overload   => $self->RespectOverload,
              max_arg_length     => $self->MaxArgLength,
          );
      }
  
      my %fields = map { $_ => 1 } $self->Fields;
      while ( my ( $key, $value ) = each %p ) {
          next if $key =~ /^(?:error|message|show_trace)$/;
  
          if ( $fields{$key} ) {
              $self->{$key} = $value;
          }
          else {
              Exception::Class::Base->throw(
                  error => "unknown field $key passed to constructor for class "
                      . ref $self );
          }
      }
  }
  
  sub context_hash {
      my $self = shift;
  
      return {
          time => $self->{time},
          pid  => $self->{pid},
          uid  => $self->{uid},
          euid => $self->{euid},
          gid  => $self->{gid},
          egid => $self->{egid},
      };
  }
  
  sub field_hash {
      my $self = shift;
  
      my $hash = {};
  
      for my $field ( $self->Fields ) {
          $hash->{$field} = $self->$field;
      }
  
      return $hash;
  }
  
  sub description {
      return 'Generic exception';
  }
  
  sub show_trace {
      my $self = shift;
  
      return 0 unless $self->{trace};
  
      if (@_) {
          $self->{show_trace} = shift;
      }
  
      return exists $self->{show_trace} ? $self->{show_trace} : $self->Trace;
  }
  
  sub as_string {
      my $self = shift;
  
      my $str = $self->full_message;
      unless ( defined $str && length $str ) {
          my $desc = $self->description;
          $str = defined $desc
              && length $desc ? "[$desc]" : "[Generic exception]";
      }
  
      $str .= "\n\n" . $self->trace->as_string
          if $self->show_trace;
  
      return $str;
  }
  
  sub full_message { $_[0]->{message} }
  
  #
  # The %seen bit protects against circular inheritance.
  #
  eval <<'EOF' if $] == 5.006;
  sub isa {
      my ( $inheritor, $base ) = @_;
      $inheritor = ref($inheritor) if ref($inheritor);
  
      my %seen;
  
      no strict 'refs';
      my @parents = ( $inheritor, @{"$inheritor\::ISA"} );
      while ( my $class = shift @parents ) {
          return 1 if $class eq $base;
  
          push @parents, grep { !$seen{$_}++ } @{"$class\::ISA"};
      }
      return 0;
  }
  EOF
  
  sub caught {
      my $class = shift;
  
      my $e = $@;
  
      return unless defined $e && blessed($e) && $e->isa($class);
      return $e;
  }
  
  1;
  
  # ABSTRACT: A base class for exception objects
  
  __END__
  
  =pod
  
  =head1 NAME
  
  Exception::Class::Base - A base class for exception objects
  
  =head1 VERSION
  
  version 1.39
  
  =head1 SYNOPSIS
  
    use Exception::Class 'MyException';
  
    eval { MyException->throw( error => 'I feel funny.' ) };
  
    print $@->error();
  
  =head1 DESCRIPTION
  
  This class is the base class for all exceptions created by
  L<Exception::Class>. It provides a number of methods for getting
  information about the exception.
  
  =for Pod::Coverage     Classes
      caught
      NoRefs
  
  =head1 METHODS
  
  =head2 MyException->Trace($boolean)
  
  Each C<Exception::Class::Base> subclass can be set individually to
  include a stacktrace when the C<as_string> method is called. The
  default is to not include a stacktrace. Calling this method with a
  value changes this behavior. It always returns the current value
  (after any change is applied).
  
  This value is inherited by any subclasses. However, if this value is
  set for a subclass, it will thereafter be independent of the value in
  C<Exception::Class::Base>.
  
  Do not call this on the C<Exception::Class::Base> class directly or
  you'll change it for all exception classes that use
  L<Exception::Class>, including ones created in modules you don't
  control.
  
  This is a class method, not an object method.
  
  =head2 MyException->UnsafeRefCapture($boolean)
  
  When a C<Devel::StackTrace> object is created, it walks through the
  stack and stores the arguments which were passed to each subroutine on
  the stack. If any of these arguments are references, then that means
  that the C<Devel::StackTrace> ends up increasing the ref count of these
  references, delaying their destruction.
  
  Since C<Exception::Class::Base> uses C<Devel::StackTrace> internally,
  this method provides a way to tell C<Devel::StackTrace> not to store
  these references. Instead, C<Devel::StackTrace> replaces references
  with their stringified representation.
  
  This method defaults to false. As with C<Trace()>, it is inherited by
  subclasses but setting it in a subclass makes it independent thereafter.
  
  Do not call this on the C<Exception::Class::Base> class directly or
  you'll change it for all exception classes that use
  L<Exception::Class>, including ones created in modules you don't
  control.
  
  =head2 MyException->RespectOverload($boolean)
  
  When a C<Devel::StackTrace> object stringifies, by default it ignores
  stringification overloading on any objects being dealt with.
  
  Since C<Exception::Class::Base> uses C<Devel::StackTrace> internally,
  this method provides a way to tell C<Devel::StackTrace> to respect
  overloading.
  
  This method defaults to false. As with C<Trace()>, it is inherited by
  subclasses but setting it in a subclass makes it independent
  thereafter.
  
  Do not call this on the C<Exception::Class::Base> class directly or
  you'll change it for all exception classes that use
  L<Exception::Class>, including ones created in modules you don't
  control.
  
  =head2 MyException->MaxArgLength($boolean)
  
  When a C<Devel::StackTrace> object stringifies, by default it displays
  the full argument for each function. This parameter can be used to
  limit the maximum length of each argument.
  
  Since C<Exception::Class::Base> uses C<Devel::StackTrace> internally,
  this method provides a way to tell C<Devel::StackTrace> to limit the
  length of arguments.
  
  This method defaults to 0. As with C<Trace()>, it is inherited by
  subclasses but setting it in a subclass makes it independent
  thereafter.
  
  Do not call this on the C<Exception::Class::Base> class directly or
  you'll change it for all exception classes that use
  L<Exception::Class>, including ones created in modules you don't
  control.
  
  =head2 MyException->Fields
  
  This method returns the extra fields defined for the given class, as
  a list.
  
  Do not call this on the C<Exception::Class::Base> class directly or
  you'll change it for all exception classes that use
  L<Exception::Class>, including ones created in modules you don't
  control.
  
  =head2 MyException->throw( $message )
  
  =head2 MyException->throw( message => $message )
  
  =head2 MyException->throw( error => $error )
  
  This method creates a new object with the given error message. If no
  error message is given, this will be an empty string. It then dies
  with this object as its argument.
  
  This method also takes a C<show_trace> parameter which indicates
  whether or not the particular exception object being created should
  show a stacktrace when its C<as_string()> method is called. This
  overrides the value of C<Trace()> for this class if it is given.
  
  The frames included in the trace can be controlled by the C<ignore_class>
  and C<ignore_package> parameters. These are passed directly to
  Devel::Stacktrace's constructor. See C<Devel::Stacktrace> for more details.
  
  If only a single value is given to the constructor it is assumed to be
  the message parameter.
  
  Additional keys corresponding to the fields defined for the particular
  exception subclass will also be accepted.
  
  =head2 MyException->new(...)
  
  This method takes the same parameters as C<throw()>, but instead of
  dying simply returns a new exception object.
  
  This method is always called when constructing a new exception object
  via the C<throw()> method.
  
  =head2 MyException->description()
  
  Returns the description for the given C<Exception::Class::Base>
  subclass. The C<Exception::Class::Base> class's description is
  "Generic exception" (this may change in the future). This is also an
  object method.
  
  =head2 $exception->rethrow()
  
  Simply dies with the object as its sole argument. It's just syntactic
  sugar. This does not change any of the object's attribute values.
  However, it will cause C<caller()> to report the die as coming from
  within the C<Exception::Class::Base> class rather than where rethrow
  was called.
  
  Of course, you always have access to the original stacktrace for the
  exception object.
  
  =head2 $exception->message()
  
  =head2 $exception->error()
  
  Returns the error/message associated with the exception.
  
  =head2 $exception->pid()
  
  Returns the pid at the time the exception was thrown.
  
  =head2 $exception->uid()
  
  Returns the real user id at the time the exception was thrown.
  
  =head2 $exception->gid()
  
  Returns the real group id at the time the exception was thrown.
  
  =head2 $exception->euid()
  
  Returns the effective user id at the time the exception was thrown.
  
  =head2 $exception->egid()
  
  Returns the effective group id at the time the exception was thrown.
  
  =head2 $exception->time()
  
  Returns the time in seconds since the epoch at the time the exception
  was thrown.
  
  =head2 $exception->package()
  
  Returns the package from which the exception was thrown.
  
  =head2 $exception->file()
  
  Returns the file within which the exception was thrown.
  
  =head2 $exception->line()
  
  Returns the line where the exception was thrown.
  
  =head2 $exception->context_hash()
  
  Returns a hash reference with the following keys:
  
  =over 4
  
  =item * time
  
  =item * pid
  
  =item * uid
  
  =item * euid
  
  =item * gid
  
  =item * egid
  
  =back
  
  =head2 $exception->field_hash()
  
  Returns a hash reference where the keys are any fields defined for the
  exception class and the values are the values associated with the field in the
  given object.
  
  =head2 $exception->trace()
  
  Returns the trace object associated with the object.
  
  =head2 $exception->show_trace($boolean)
  
  This method can be used to set whether or not a stack trace is
  included when the as_string method is called or the object is
  stringified.
  
  =head2 $exception->as_string()
  
  Returns a string form of the error message (something like what you'd
  expect from die). If the class or object is set to show traces then
  then the full trace is also included. The result looks like
  C<Carp::confess()>.
  
  =head2 $exception->full_message()
  
  Called by the C<as_string()> method to get the message. By default,
  this is the same as calling the C<message()> method, but may be
  overridden by a subclass. See below for details.
  
  =head1 LIGHTWEIGHT EXCEPTIONS
  
  A lightweight exception is one which records no information about its context
  when it is created. This can be achieved by setting C<<
  $class->NoContextInfo() >> to a true value.
  
  You can make this the default for a class of exceptions by setting it after
  creating the class:
  
    use Exception::Class (
        'LightWeight',
        'HeavyWeight',
    );
  
    LightWeight->NoContextInfo(1);
  
  A lightweight exception does have a stack trace object, nor does it record the
  time, pid, uid, euid, gid, or egid. It only has a message.
  
  =head1 OVERLOADING
  
  C<Exception::Class::Base> objects are overloaded so that
  stringification produces a normal error message. This just calls the
  C<< $exception->as_string() >> method described above. This means
  that you can just C<print $@> after an C<eval> and not worry about
  whether or not its an actual object. It also means an application or
  module could do this:
  
   $SIG{__DIE__} = sub { Exception::Class::Base->throw( error => join '', @_ ); };
  
  and this would probably not break anything (unless someone was
  expecting a different type of exception object from C<die()>).
  
  =head1 OVERRIDING THE as_string METHOD
  
  By default, the C<as_string()> method simply returns the value
  C<message> or C<error> param plus a stack trace, if the class's
  C<Trace()> method returns a true value or C<show_trace> was set when
  creating the exception.
  
  However, once you add new fields to a subclass, you may want to
  include those fields in the stringified error.
  
  Inside the C<as_string()> method, the message (non-stack trace)
  portion of the error is generated by calling the C<full_message()>
  method. This can be easily overridden. For example:
  
    sub full_message {
        my $self = shift;
  
        my $msg = $self->message;
  
        $msg .= " and foo was " . $self->foo;
  
        return $msg;
    }
  
  =head1 AUTHOR
  
  Dave Rolsky <autarch@urth.org>
  
  =head1 COPYRIGHT AND LICENSE
  
  This software is copyright (c) 2014 by David Rolsky.
  
  This is free software; you can redistribute it and/or modify it under
  the same terms as the Perl 5 programming language system itself.
  
  =cut
EXCEPTION_CLASS_BASE

$fatpacked{"Fatal.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'FATAL';
  package Fatal;
  
  # ABSTRACT: Replace functions with equivalents which succeed or die
  
  use 5.008;  # 5.8.x needed for autodie
  use Carp;
  use strict;
  use warnings;
  use Tie::RefHash;   # To cache subroutine refs
  use Config;
  use Scalar::Util qw(set_prototype);
  
  use autodie::ScopeUtil qw(on_end_of_compile_scope);
  
  use constant PERL510     => ( $] >= 5.010 );
  
  use constant LEXICAL_TAG => q{:lexical};
  use constant VOID_TAG    => q{:void};
  use constant INSIST_TAG  => q{!};
  
  # Keys for %Cached_fatalised_sub  (used in 3rd level)
  use constant CACHE_AUTODIE_LEAK_GUARD    => 0;
  use constant CACHE_FATAL_WRAPPER         => 1;
  use constant CACHE_FATAL_VOID            => 2;
  
  
  use constant ERROR_NOARGS    => 'Cannot use lexical %s with no arguments';
  use constant ERROR_VOID_LEX  => VOID_TAG.' cannot be used with lexical scope';
  use constant ERROR_LEX_FIRST => LEXICAL_TAG.' must be used as first argument';
  use constant ERROR_NO_LEX    => "no %s can only start with ".LEXICAL_TAG;
  use constant ERROR_BADNAME   => "Bad subroutine name for %s: %s";
  use constant ERROR_NOTSUB    => "%s is not a Perl subroutine";
  use constant ERROR_NOT_BUILT => "%s is neither a builtin, nor a Perl subroutine";
  use constant ERROR_NOHINTS   => "No user hints defined for %s";
  
  use constant ERROR_CANT_OVERRIDE => "Cannot make the non-overridable builtin %s fatal";
  
  use constant ERROR_NO_IPC_SYS_SIMPLE => "IPC::System::Simple required for Fatalised/autodying system()";
  
  use constant ERROR_IPC_SYS_SIMPLE_OLD => "IPC::System::Simple version %f required for Fatalised/autodying system().  We only have version %f";
  
  use constant ERROR_AUTODIE_CONFLICT => q{"no autodie '%s'" is not allowed while "use Fatal '%s'" is in effect};
  
  use constant ERROR_FATAL_CONFLICT => q{"use Fatal '%s'" is not allowed while "no autodie '%s'" is in effect};
  
  use constant ERROR_58_HINTS => q{Non-subroutine %s hints for %s are not supported under Perl 5.8.x};
  
  # Older versions of IPC::System::Simple don't support all the
  # features we need.
  
  use constant MIN_IPC_SYS_SIMPLE_VER => 0.12;
  
  our $VERSION = '2.26'; # VERSION: Generated by DZP::OurPkg::Version
  
  our $Debug ||= 0;
  
  # EWOULDBLOCK values for systems that don't supply their own.
  # Even though this is defined with our, that's to help our
  # test code.  Please don't rely upon this variable existing in
  # the future.
  
  our %_EWOULDBLOCK = (
      MSWin32 => 33,
  );
  
  $Carp::CarpInternal{'Fatal'} = 1;
  $Carp::CarpInternal{'autodie'} = 1;
  $Carp::CarpInternal{'autodie::exception'} = 1;
  
  # the linux parisc port has separate EAGAIN and EWOULDBLOCK,
  # and the kernel returns EAGAIN
  my $try_EAGAIN = ($^O eq 'linux' and $Config{archname} =~ /hppa|parisc/) ? 1 : 0;
  
  # We have some tags that can be passed in for use with import.
  # These are all assumed to be CORE::
  
  my %TAGS = (
      ':io'      => [qw(:dbm :file :filesys :ipc :socket
                         read seek sysread syswrite sysseek )],
      ':dbm'     => [qw(dbmopen dbmclose)],
      ':file'    => [qw(open close flock sysopen fcntl binmode
                       ioctl truncate)],
      ':filesys' => [qw(opendir closedir chdir link unlink rename mkdir
                        symlink rmdir readlink chmod chown utime)],
      ':ipc'     => [qw(:msg :semaphore :shm pipe kill)],
      ':msg'     => [qw(msgctl msgget msgrcv msgsnd)],
      ':threads' => [qw(fork)],
      ':semaphore'=>[qw(semctl semget semop)],
      ':shm'     => [qw(shmctl shmget shmread)],
      ':system'  => [qw(system exec)],
  
      # Can we use qw(getpeername getsockname)? What do they do on failure?
      # TODO - Can socket return false?
      ':socket'  => [qw(accept bind connect getsockopt listen recv send
                     setsockopt shutdown socketpair)],
  
      # Our defaults don't include system(), because it depends upon
      # an optional module, and it breaks the exotic form.
      #
      # This *may* change in the future.  I'd love IPC::System::Simple
      # to be a dependency rather than a recommendation, and hence for
      # system() to be autodying by default.
  
      ':default' => [qw(:io :threads)],
  
      # Everything in v2.07 and brefore. This was :default less chmod and chown
      ':v207'    => [qw(:threads :dbm :socket read seek sysread
                     syswrite sysseek open close flock sysopen fcntl fileno
                     binmode ioctl truncate opendir closedir chdir link unlink
                     rename mkdir symlink rmdir readlink umask
                     :msg :semaphore :shm pipe)],
  
      # Chmod was added in 2.13
      ':v213'    => [qw(:v207 chmod)],
  
      # chown, utime, kill were added in 2.14
      ':v214'    => [qw(:v213 chown utime kill)],
  
      # umask was removed in 2.26
      ':v225' => [qw(:io :threads umask fileno)],
  
      # Version specific tags.  These allow someone to specify
      # use autodie qw(:1.994) and know exactly what they'll get.
  
      ':1.994' => [qw(:v207)],
      ':1.995' => [qw(:v207)],
      ':1.996' => [qw(:v207)],
      ':1.997' => [qw(:v207)],
      ':1.998' => [qw(:v207)],
      ':1.999' => [qw(:v207)],
      ':1.999_01' => [qw(:v207)],
      ':2.00'  => [qw(:v207)],
      ':2.01'  => [qw(:v207)],
      ':2.02'  => [qw(:v207)],
      ':2.03'  => [qw(:v207)],
      ':2.04'  => [qw(:v207)],
      ':2.05'  => [qw(:v207)],
      ':2.06'  => [qw(:v207)],
      ':2.06_01' => [qw(:v207)],
      ':2.07'  => [qw(:v207)],     # Last release without chmod
      ':2.08'  => [qw(:v213)],
      ':2.09'  => [qw(:v213)],
      ':2.10'  => [qw(:v213)],
      ':2.11'  => [qw(:v213)],
      ':2.12'  => [qw(:v213)],
      ':2.13'  => [qw(:v213)],     # Last release without chown
      ':2.14'  => [qw(:v225)],
      ':2.15'  => [qw(:v225)],
      ':2.16'  => [qw(:v225)],
      ':2.17'  => [qw(:v225)],
      ':2.18'  => [qw(:v225)],
      ':2.19'  => [qw(:v225)],
      ':2.20'  => [qw(:v225)],
      ':2.21'  => [qw(:v225)],
      ':2.22'  => [qw(:v225)],
      ':2.23'  => [qw(:v225)],
      ':2.24'  => [qw(:v225)],
      ':2.25'  => [qw(:v225)],
      ':2.26'  => [qw(:default)],
  );
  
  
  {
      # Expand :all immediately by expanding and flattening all tags.
      # _expand_tag is not really optimised for expanding the ":all"
      # case (i.e. keys %TAGS, or values %TAGS for that matter), so we
      # just do it here.
      #
      # NB: The %tag_cache/_expand_tag relies on $TAGS{':all'} being
      # pre-expanded.
      my %seen;
      my @all = grep {
          !/^:/ && !$seen{$_}++
      } map { @{$_} } values %TAGS;
      $TAGS{':all'} = \@all;
  }
  
  # This hash contains subroutines for which we should
  # subroutine() // die() rather than subroutine() || die()
  
  my %Use_defined_or;
  
  # CORE::open returns undef on failure.  It can legitimately return
  # 0 on success, eg: open(my $fh, '-|') || exec(...);
  
  @Use_defined_or{qw(
      CORE::fork
      CORE::recv
      CORE::send
      CORE::open
      CORE::fileno
      CORE::read
      CORE::readlink
      CORE::sysread
      CORE::syswrite
      CORE::sysseek
      CORE::umask
  )} = ();
  
  # Some functions can return true because they changed *some* things, but
  # not all of them.  This is a list of offending functions, and how many
  # items to subtract from @_ to determine the "success" value they return.
  
  my %Returns_num_things_changed = (
      'CORE::chmod'  => 1,
      'CORE::chown'  => 2,
      'CORE::kill'   => 1,  # TODO: Could this return anything on negative args?
      'CORE::unlink' => 0,
      'CORE::utime'  => 2,
  );
  
  # Optional actions to take on the return value before returning it.
  
  my %Retval_action = (
      "CORE::open"        => q{
  
      # apply the open pragma from our caller
      if( defined $retval && !( @_ >= 3 && $_[1] =~ /:/ )) {
          # Get the caller's hint hash
          my $hints = (caller 0)[10];
  
          # Decide if we're reading or writing and apply the appropriate encoding
          # These keys are undocumented.
          # Match what PerlIO_context_layers() does.  Read gets the read layer,
          # everything else gets the write layer.
          my $encoding = $_[1] =~ /^\+?>/ ? $hints->{"open>"} : $hints->{"open<"};
  
          # Apply the encoding, if any.
          if( $encoding ) {
              binmode $_[0], $encoding;
          }
      }
  
  },
      "CORE::sysopen"     => q{
  
      # apply the open pragma from our caller
      if( defined $retval ) {
          # Get the caller's hint hash
          my $hints = (caller 0)[10];
  
          require Fcntl;
  
          # Decide if we're reading or writing and apply the appropriate encoding.
          # Match what PerlIO_context_layers() does.  Read gets the read layer,
          # everything else gets the write layer.
          my $open_read_only = !($_[2] ^ Fcntl::O_RDONLY());
          my $encoding = $open_read_only ? $hints->{"open<"} : $hints->{"open>"};
  
          # Apply the encoding, if any.
          if( $encoding ) {
              binmode $_[0], $encoding;
          }
      }
  
  },
  );
  
  my %reusable_builtins;
  
  # "Wait!" I hear you cry, "truncate() and chdir() are not reuseable! They can
  # take file and directory handles, which are package depedent."
  #
  # You would be correct, except that prototype() returns signatures which don't
  # allow for passing of globs, and nobody's complained about that. You can
  # still use \*FILEHANDLE, but that results in a reference coming through,
  # and it's already pointing to the filehandle in the caller's packge, so
  # it's all okay.
  
  @reusable_builtins{qw(
      CORE::fork
      CORE::kill
      CORE::truncate
      CORE::chdir
      CORE::link
      CORE::unlink
      CORE::rename
      CORE::mkdir
      CORE::symlink
      CORE::rmdir
      CORE::readlink
      CORE::umask
      CORE::chmod
      CORE::chown
      CORE::utime
      CORE::msgctl
      CORE::msgget
      CORE::msgrcv
      CORE::msgsnd
      CORE::semctl
      CORE::semget
      CORE::semop
      CORE::shmctl
      CORE::shmget
      CORE::shmread
  )} = ();
  
  # Cached_fatalised_sub caches the various versions of our
  # fatalised subs as they're produced.  This means we don't
  # have to build our own replacement of CORE::open and friends
  # for every single package that wants to use them.
  
  my %Cached_fatalised_sub = ();
  
  # Every time we're called with package scope, we record the subroutine
  # (including package or CORE::) in %Package_Fatal.  This allows us
  # to detect illegal combinations of autodie and Fatal, and makes sure
  # we don't accidently make a Fatal function autodying (which isn't
  # very useful).
  
  my %Package_Fatal = ();
  
  # The first time we're called with a user-sub, we cache it here.
  # In the case of a "no autodie ..." we put back the cached copy.
  
  my %Original_user_sub = ();
  
  # Is_fatalised_sub simply records a big map of fatalised subroutine
  # refs.  It means we can avoid repeating work, or fatalising something
  # we've already processed.
  
  my  %Is_fatalised_sub = ();
  tie %Is_fatalised_sub, 'Tie::RefHash';
  
  # Our trampoline cache allows us to cache trampolines which are used to
  # bounce leaked wrapped core subroutines to their actual core counterparts.
  
  my %Trampoline_cache;
  
  # A cache mapping "CORE::<name>" to their prototype.  Turns out that if
  # you "use autodie;" enough times, this pays off.
  my %CORE_prototype_cache;
  
  # We use our package in a few hash-keys.  Having it in a scalar is
  # convenient.  The "guard $PACKAGE" string is used as a key when
  # setting up lexical guards.
  
  my $PACKAGE       = __PACKAGE__;
  my $NO_PACKAGE    = "no $PACKAGE";      # Used to detect 'no autodie'
  
  # Here's where all the magic happens when someone write 'use Fatal'
  # or 'use autodie'.
  
  sub import {
      my $class        = shift(@_);
      my @original_args = @_;
      my $void         = 0;
      my $lexical      = 0;
      my $insist_hints = 0;
  
      my ($pkg, $filename) = caller();
  
      @_ or return;   # 'use Fatal' is a no-op.
  
      # If we see the :lexical flag, then _all_ arguments are
      # changed lexically
  
      if ($_[0] eq LEXICAL_TAG) {
          $lexical = 1;
          shift @_;
  
          # If we see no arguments and :lexical, we assume they
          # wanted ':default'.
  
          if (@_ == 0) {
              push(@_, ':default');
          }
  
          # Don't allow :lexical with :void, it's needlessly confusing.
          if ( grep { $_ eq VOID_TAG } @_ ) {
              croak(ERROR_VOID_LEX);
          }
      }
  
      if ( grep { $_ eq LEXICAL_TAG } @_ ) {
          # If we see the lexical tag as the non-first argument, complain.
          croak(ERROR_LEX_FIRST);
      }
  
      my @fatalise_these =  @_;
  
      # These subs will get unloaded at the end of lexical scope.
      my %unload_later;
      # These subs are to be installed into callers namespace.
      my %install_subs;
  
      # Use _translate_import_args to expand tags for us.  It will
      # pass-through unknown tags (i.e. we have to manually handle
      # VOID_TAG).
      #
      # NB: _translate_import_args re-orders everything for us, so
      # we don't have to worry about stuff like:
      #
      #     :default :void :io
      #
      # That will (correctly) translated into
      #
      #     expand(:defaults-without-io) :void :io
      #
      # by _translate_import_args.
      for my $func ($class->_translate_import_args(@fatalise_these)) {
  
          if ($func eq VOID_TAG) {
  
              # When we see :void, set the void flag.
              $void = 1;
  
          } elsif ($func eq INSIST_TAG) {
  
              $insist_hints = 1;
  
          } else {
  
              # Otherwise, fatalise it.
  
              # Check to see if there's an insist flag at the front.
              # If so, remove it, and insist we have hints for this sub.
              my $insist_this = $insist_hints;
  
              if (substr($func, 0, 1) eq '!') {
                  $func = substr($func, 1);
                  $insist_this = 1;
              }
  
              # We're going to make a subroutine fatalistic.
              # However if we're being invoked with 'use Fatal qw(x)'
              # and we've already been called with 'no autodie qw(x)'
              # in the same scope, we consider this to be an error.
              # Mixing Fatal and autodie effects was considered to be
              # needlessly confusing on p5p.
  
              my $sub = $func;
              $sub = "${pkg}::$sub" unless $sub =~ /::/;
  
              # If we're being called as Fatal, and we've previously
              # had a 'no X' in scope for the subroutine, then complain
              # bitterly.
  
              if (! $lexical and $^H{$NO_PACKAGE}{$sub}) {
                   croak(sprintf(ERROR_FATAL_CONFLICT, $func, $func));
              }
  
              # We're not being used in a confusing way, so make
              # the sub fatal.  Note that _make_fatal returns the
              # old (original) version of the sub, or undef for
              # built-ins.
  
              my $sub_ref = $class->_make_fatal(
                  $func, $pkg, $void, $lexical, $filename,
                  $insist_this, \%install_subs,
              );
  
              $Original_user_sub{$sub} ||= $sub_ref;
  
              # If we're making lexical changes, we need to arrange
              # for them to be cleaned at the end of our scope, so
              # record them here.
  
              $unload_later{$func} = $sub_ref if $lexical;
          }
      }
  
      $class->_install_subs($pkg, \%install_subs);
  
      if ($lexical) {
  
          # Dark magic to have autodie work under 5.8
          # Copied from namespace::clean, that copied it from
          # autobox, that found it on an ancient scroll written
          # in blood.
  
          # This magic bit causes %^H to be lexically scoped.
  
          $^H |= 0x020000;
  
          # Our package guard gets invoked when we leave our lexical
          # scope.
  
          on_end_of_compile_scope(sub {
              $class->_install_subs($pkg, \%unload_later);
          });
  
          # To allow others to determine when autodie was in scope,
          # and with what arguments, we also set a %^H hint which
          # is how we were called.
  
          # This feature should be considered EXPERIMENTAL, and
          # may change without notice.  Please e-mail pjf@cpan.org
          # if you're actually using it.
  
          $^H{autodie} = "$PACKAGE @original_args";
  
      }
  
      return;
  
  }
  
  # The code here is originally lifted from namespace::clean,
  # by Robert "phaylon" Sedlacek.
  #
  # It's been redesigned after feedback from ikegami on perlmonks.
  # See http://perlmonks.org/?node_id=693338 .  Ikegami rocks.
  #
  # Given a package, and hash of (subname => subref) pairs,
  # we install the given subroutines into the package.  If
  # a subref is undef, the subroutine is removed.  Otherwise
  # it replaces any existing subs which were already there.
  
  sub _install_subs {
      my ($class, $pkg, $subs_to_reinstate) = @_;
  
      my $pkg_sym = "${pkg}::";
  
      # It does not hurt to do this in a predictable order, and might help debugging.
      foreach my $sub_name (sort keys %$subs_to_reinstate) {
  
          # We will repeatedly mess with stuff that strict "refs" does
          # not like.  So lets just disable it once for this entire
          # scope.
          no strict qw(refs);   ## no critic
  
          my $sub_ref= $subs_to_reinstate->{$sub_name};
  
          my $full_path = $pkg_sym.$sub_name;
          my $oldglob = *$full_path;
  
          # Nuke the old glob.
          delete $pkg_sym->{$sub_name};
  
          # For some reason this local *alias = *$full_path triggers an
          # "only used once" warning.  Not entirely sure why, but at
          # least it is easy to silence.
          no warnings qw(once);
          local *alias = *$full_path;
          use warnings qw(once);
  
          # Copy innocent bystanders back.  Note that we lose
          # formats; it seems that Perl versions up to 5.10.0
          # have a bug which causes copying formats to end up in
          # the scalar slot.  Thanks to Ben Morrow for spotting this.
  
          foreach my $slot (qw( SCALAR ARRAY HASH IO ) ) {
              next unless defined *$oldglob{$slot};
              *alias = *$oldglob{$slot};
          }
  
          if ($sub_ref) {
              *$full_path = $sub_ref;
          }
      }
  
      return;
  }
  
  sub unimport {
      my $class = shift;
  
      # Calling "no Fatal" must start with ":lexical"
      if ($_[0] ne LEXICAL_TAG) {
          croak(sprintf(ERROR_NO_LEX,$class));
      }
  
      shift @_;   # Remove :lexical
  
      my $pkg = (caller)[0];
  
      # If we've been called with arguments, then the developer
      # has explicitly stated 'no autodie qw(blah)',
      # in which case, we disable Fatalistic behaviour for 'blah'.
  
      my @unimport_these = @_ ? @_ : ':all';
      my (%uninstall_subs, %reinstall_subs);
  
      for my $symbol ($class->_translate_import_args(@unimport_these)) {
  
          my $sub = $symbol;
          $sub = "${pkg}::$sub" unless $sub =~ /::/;
  
          # If 'blah' was already enabled with Fatal (which has package
          # scope) then, this is considered an error.
  
          if (exists $Package_Fatal{$sub}) {
              croak(sprintf(ERROR_AUTODIE_CONFLICT,$symbol,$symbol));
          }
  
          # Record 'no autodie qw($sub)' as being in effect.
          # This is to catch conflicting semantics elsewhere
          # (eg, mixing Fatal with no autodie)
  
          $^H{$NO_PACKAGE}{$sub} = 1;
          # Record the current sub to be reinstalled at end of scope
          # and then restore the original (can be undef for "CORE::"
          # subs)
          $reinstall_subs{$symbol} = \&$sub;
          $uninstall_subs{$symbol} = $Original_user_sub{$sub};
  
      }
  
      $class->_install_subs($pkg, \%uninstall_subs);
      on_end_of_compile_scope(sub {
          $class->_install_subs($pkg, \%reinstall_subs);
      });
  
      return;
  
  }
  
  sub _translate_import_args {
      my ($class, @args) = @_;
      my @result;
      my %seen;
  
      if (@args < 2) {
          # Optimize for this case, as it is fairly common.  (e.g. use
          # autodie; or use autodie qw(:all); both trigger this).
          return unless @args;
  
          # Not a (known) tag, pass through.
          return @args unless exists($TAGS{$args[0]});
  
          # Strip "CORE::" from all elements in the list as import and
          # unimport does not handle the "CORE::" prefix too well.
          #
          # NB: we use substr as it is faster than s/^CORE::// and
          # it does not change the elements.
          return map { substr($_, 6) } @{ $class->_expand_tag($args[0]) };
      }
  
      # We want to translate
      #
      #     :default :void :io
      #
      # into (pseudo-ish):
      #
      #     expanded(:threads) :void expanded(:io)
      #
      # We accomplish this by "reverse, expand + filter, reverse".
      for my $a (reverse(@args)) {
          if (exists $TAGS{$a}) {
              my $expanded = $class->_expand_tag($a);
              push(@result,
                   # Remove duplicates after ...
                   grep { !$seen{$_}++ }
                   # we have stripped CORE:: (see above)
                   map { substr($_, 6) }
                   # We take the elements in reverse order
                   # (as @result be reversed later).
                   reverse(@{$expanded}));
          } else {
              # pass through - no filtering here for tags.
              #
              # The reason for not filtering tags cases like:
              #
              #    ":default :void :io :void :threads"
              #
              # As we have reversed args, we see this as:
              #
              #    ":threads :void :io :void* :default*"
              #
              # (Entries marked with "*" will be filtered out completely).  When
              # reversed again, this will be:
              #
              #    ":io :void :threads"
              #
              # But we would rather want it to be:
              #
              #    ":void :io :threads" or ":void :io :void :threads"
              #
  
              my $letter = substr($a, 0, 1);
              if ($letter ne ':' && $a ne INSIST_TAG) {
                  next if $seen{$a}++;
                  if ($letter eq '!' and $seen{substr($a, 1)}++) {
                      my $name = substr($a, 1);
                      # People are being silly and doing:
                      #
                      #    use autodie qw(!a a);
                      #
                      # Enjoy this little O(n) clean up...
                      @result = grep { $_ ne $name } @result;
                  }
              }
              push @result, $a;
          }
      }
      # Reverse the result to restore the input order
      return reverse(@result);
  }
  
  
  # NB: Perl::Critic's dump-autodie-tag-contents depends upon this
  # continuing to work.
  
  {
      # We assume that $TAGS{':all'} is pre-expanded and just fill it in
      # from the beginning.
      my %tag_cache = (
          'all' => [map { "CORE::$_" } @{$TAGS{':all'}}],
      );
  
      # Expand a given tag (e.g. ":default") into a listref containing
      # all sub names covered by that tag.  Each sub is returned as
      # "CORE::<name>" (i.e. "CORE::open" rather than "open").
      #
      # NB: the listref must not be modified.
      sub _expand_tag {
          my ($class, $tag) = @_;
  
          if (my $cached = $tag_cache{$tag}) {
              return $cached;
          }
  
          if (not exists $TAGS{$tag}) {
              croak "Invalid exception class $tag";
          }
  
          my @to_process = @{$TAGS{$tag}};
  
          # If the tag is basically an alias of another tag (like e.g. ":2.11"),
          # then just share the resulting reference with the original content (so
          # we only pay for an extra reference for the alias memory-wise).
          if (@to_process == 1 && substr($to_process[0], 0, 1) eq ':') {
              # We could do this for "non-tags" as well, but that only occurs
              # once at the time of writing (":threads" => ["fork"]), so
              # probably not worth it.
              my $expanded = $class->_expand_tag($to_process[0]);
              $tag_cache{$tag} = $expanded;
              return $expanded;
          }
  
          my %seen = ();
          my @taglist = ();
  
          for my $item (@to_process) {
              # substr is more efficient than m/^:/ for stuff like this,
              # at the price of being a bit more verbose/low-level.
              if (substr($item, 0, 1) eq ':') {
                  # Use recursion here to ensure we expand a tag at most once.
  
                  my $expanded = $class->_expand_tag($item);
                  push @taglist, grep { !$seen{$_}++ } @{$expanded};
              } else {
                  my $subname = "CORE::$item";
                  push @taglist, $subname
                      unless $seen{$subname}++;
              }
          }
  
          $tag_cache{$tag} = \@taglist;
  
          return \@taglist;
  
      }
  
  }
  
  # This code is from the original Fatal.  It scares me.
  # It is 100% compatible with the 5.10.0 Fatal module, right down
  # to the scary 'XXXX' comment.  ;)
  
  sub fill_protos {
      my $proto = shift;
      my ($n, $isref, @out, @out1, $seen_semi) = -1;
      if ($proto =~ m{^\s* (?: [;] \s*)? \@}x) {
          # prototype is entirely slurp - special case that does not
          # require any handling.
          return ([0, '@_']);
      }
  
      while ($proto =~ /\S/) {
          $n++;
          push(@out1,[$n,@out]) if $seen_semi;
          push(@out, $1 . "{\$_[$n]}"), next if $proto =~ s/^\s*\\([\@%\$\&])//;
          push(@out, "\$_[$n]"),        next if $proto =~ s/^\s*([_*\$&])//;
          push(@out, "\@_[$n..\$#_]"),  last if $proto =~ s/^\s*(;\s*)?\@//;
          $seen_semi = 1, $n--,         next if $proto =~ s/^\s*;//; # XXXX ????
          die "Internal error: Unknown prototype letters: \"$proto\"";
      }
      push(@out1,[$n+1,@out]);
      return @out1;
  }
  
  # This is a backwards compatible version of _write_invocation.  It's
  # recommended you don't use it.
  
  sub write_invocation {
      my ($core, $call, $name, $void, @args) = @_;
  
      return Fatal->_write_invocation(
          $core, $call, $name, $void,
          0,      # Lexical flag
          undef,  # Sub, unused in legacy mode
          undef,  # Subref, unused in legacy mode.
          @args
      );
  }
  
  # This version of _write_invocation is used internally.  It's not
  # recommended you call it from external code, as the interface WILL
  # change in the future.
  
  sub _write_invocation {
  
      my ($class, $core, $call, $name, $void, $lexical, $sub, $sref, @argvs) = @_;
  
      if (@argvs == 1) {        # No optional arguments
  
          my @argv = @{$argvs[0]};
          shift @argv;
  
          return $class->_one_invocation($core,$call,$name,$void,$sub,! $lexical, $sref, @argv);
  
      } else {
          my $else = "\t";
          my (@out, @argv, $n);
          while (@argvs) {
              @argv = @{shift @argvs};
              $n = shift @argv;
  
              my $condition = "\@_ == $n";
  
              if (@argv and $argv[-1] =~ /[#@]_/) {
                  # This argv ends with '@' in the prototype, so it matches
                  # any number of args >= the number of expressions in the
                  # argv.
                  $condition = "\@_ >= $n";
              }
  
              push @out, "${else}if ($condition) {\n";
  
              $else = "\t} els";
  
          push @out, $class->_one_invocation($core,$call,$name,$void,$sub,! $lexical, $sref, @argv);
          }
          push @out, qq[
              }
              die "Internal error: $name(\@_): Do not expect to get ", scalar(\@_), " arguments";
      ];
  
          return join '', @out;
      }
  }
  
  
  # This is a slim interface to ensure backward compatibility with
  # anyone doing very foolish things with old versions of Fatal.
  
  sub one_invocation {
      my ($core, $call, $name, $void, @argv) = @_;
  
      return Fatal->_one_invocation(
          $core, $call, $name, $void,
          undef,   # Sub.  Unused in back-compat mode.
          1,       # Back-compat flag
          undef,   # Subref, unused in back-compat mode.
          @argv
      );
  
  }
  
  # This is the internal interface that generates code.
  # NOTE: This interface WILL change in the future.  Please do not
  # call this subroutine directly.
  
  # TODO: Whatever's calling this code has already looked up hints.  Pass
  # them in, rather than look them up a second time.
  
  sub _one_invocation {
      my ($class, $core, $call, $name, $void, $sub, $back_compat, $sref, @argv) = @_;
  
  
      # If someone is calling us directly (a child class perhaps?) then
      # they could try to mix void without enabling backwards
      # compatibility.  We just don't support this at all, so we gripe
      # about it rather than doing something unwise.
  
      if ($void and not $back_compat) {
          Carp::confess("Internal error: :void mode not supported with $class");
      }
  
      # @argv only contains the results of the in-built prototype
      # function, and is therefore safe to interpolate in the
      # code generators below.
  
      # TODO - The following clobbers context, but that's what the
      #        old Fatal did.  Do we care?
  
      if ($back_compat) {
  
          # Use Fatal qw(system) will never be supported.  It generated
          # a compile-time error with legacy Fatal, and there's no reason
          # to support it when autodie does a better job.
  
          if ($call eq 'CORE::system') {
              return q{
                  croak("UNIMPLEMENTED: use Fatal qw(system) not supported.");
              };
          }
  
          local $" = ', ';
  
          if ($void) {
              return qq/return (defined wantarray)?$call(@argv):
                     $call(@argv) || Carp::croak("Can't $name(\@_)/ .
                     ($core ? ': $!' : ', \$! is \"$!\"') . '")'
          } else {
              return qq{return $call(@argv) || Carp::croak("Can't $name(\@_)} .
                     ($core ? ': $!' : ', \$! is \"$!\"') . '")';
          }
      }
  
      # The name of our original function is:
      #   $call if the function is CORE
      #   $sub if our function is non-CORE
  
      # The reason for this is that $call is what we're actually
      # calling.  For our core functions, this is always
      # CORE::something.  However for user-defined subs, we're about to
      # replace whatever it is that we're calling; as such, we actually
      # calling a subroutine ref.
  
      my $human_sub_name = $core ? $call : $sub;
  
      # Should we be testing to see if our result is defined, or
      # just true?
  
      my $use_defined_or;
  
      my $hints;      # All user-sub hints, including list hints.
  
      if ( $core ) {
  
          # Core hints are built into autodie.
  
          $use_defined_or = exists ( $Use_defined_or{$call} );
  
      }
      else {
  
          # User sub hints are looked up using autodie::hints,
          # since users may wish to add their own hints.
  
          require autodie::hints;
  
          $hints = autodie::hints->get_hints_for( $sref );
  
          # We'll look up the sub's fullname.  This means we
          # get better reports of where it came from in our
          # error messages, rather than what imported it.
  
          $human_sub_name = autodie::hints->sub_fullname( $sref );
  
      }
  
      # Checks for special core subs.
  
      if ($call eq 'CORE::system') {
  
          # Leverage IPC::System::Simple if we're making an autodying
          # system.
  
          local $" = ", ";
  
          # We need to stash $@ into $E, rather than using
          # local $@ for the whole sub.  If we don't then
          # any exceptions from internal errors in autodie/Fatal
          # will mysteriously disappear before propagating
          # upwards.
  
          return qq{
              my \$retval;
              my \$E;
  
  
              {
                  local \$@;
  
                  eval {
                      \$retval = IPC::System::Simple::system(@argv);
                  };
  
                  \$E = \$@;
              }
  
              if (\$E) {
  
                  # TODO - This can't be overridden in child
                  # classes!
  
                  die autodie::exception::system->new(
                      function => q{CORE::system}, args => [ @argv ],
                      message => "\$E", errno => \$!,
                  );
              }
  
              return \$retval;
          };
  
      }
  
      local $" = ', ';
  
      # If we're going to throw an exception, here's the code to use.
      my $die = qq{
          die $class->throw(
              function => q{$human_sub_name}, args => [ @argv ],
              pragma => q{$class}, errno => \$!,
              context => \$context, return => \$retval,
              eval_error => \$@
          )
      };
  
      if ($call eq 'CORE::flock') {
  
          # flock needs special treatment.  When it fails with
          # LOCK_UN and EWOULDBLOCK, then it's not really fatal, it just
          # means we couldn't get the lock right now.
  
          require POSIX;      # For POSIX::EWOULDBLOCK
  
          local $@;   # Don't blat anyone else's $@.
  
          # Ensure that our vendor supports EWOULDBLOCK.  If they
          # don't (eg, Windows), then we use known values for its
          # equivalent on other systems.
  
          my $EWOULDBLOCK = eval { POSIX::EWOULDBLOCK(); }
                            || $_EWOULDBLOCK{$^O}
                            || _autocroak("Internal error - can't overload flock - EWOULDBLOCK not defined on this system.");
          my $EAGAIN = $EWOULDBLOCK;
          if ($try_EAGAIN) {
              $EAGAIN = eval { POSIX::EAGAIN(); }
                            || _autocroak("Internal error - can't overload flock - EAGAIN not defined on this system.");
          }
  
          require Fcntl;      # For Fcntl::LOCK_NB
  
          return qq{
  
              my \$context = wantarray() ? "list" : "scalar";
  
              # Try to flock.  If successful, return it immediately.
  
              my \$retval = $call(@argv);
              return \$retval if \$retval;
  
              # If we failed, but we're using LOCK_NB and
              # returned EWOULDBLOCK, it's not a real error.
  
              if (\$_[1] & Fcntl::LOCK_NB() and
                  (\$! == $EWOULDBLOCK or
                  ($try_EAGAIN and \$! == $EAGAIN ))) {
                  return \$retval;
              }
  
              # Otherwise, we failed.  Die noisily.
  
              $die;
  
          };
      }
  
      if (exists $Returns_num_things_changed{$call}) {
  
          # Some things return the number of things changed (like
          # chown, kill, chmod, etc). We only consider these successful
          # if *all* the things are changed.
  
          return qq[
              my \$num_things = \@_ - $Returns_num_things_changed{$call};
              my \$retval = $call(@argv);
  
              if (\$retval != \$num_things) {
  
                  # We need \$context to throw an exception.
                  # It's *always* set to scalar, because that's how
                  # autodie calls chown() above.
  
                  my \$context = "scalar";
                  $die;
              }
  
              return \$retval;
          ];
      }
  
      # AFAIK everything that can be given an unopned filehandle
      # will fail if it tries to use it, so we don't really need
      # the 'unopened' warning class here.  Especially since they
      # then report the wrong line number.
  
      # Other warnings are disabled because they produce excessive
      # complaints from smart-match hints under 5.10.1.
  
      my $code = qq[
          no warnings qw(unopened uninitialized numeric);
          no if \$\] >= 5.017011, warnings => "experimental::smartmatch";
  
          if (wantarray) {
              my \@results = $call(@argv);
              my \$retval  = \\\@results;
              my \$context = "list";
  
      ];
  
      my $retval_action = $Retval_action{$call} || '';
  
      if ( $hints and ( ref($hints->{list} ) || "" ) eq 'CODE' ) {
  
          # NB: Subroutine hints are passed as a full list.
          # This differs from the 5.10.0 smart-match behaviour,
          # but means that context unaware subroutines can use
          # the same hints in both list and scalar context.
  
          $code .= qq{
              if ( \$hints->{list}->(\@results) ) { $die };
          };
      }
      elsif ( PERL510 and $hints ) {
          $code .= qq{
              if ( \@results ~~ \$hints->{list} ) { $die };
          };
      }
      elsif ( $hints ) {
          croak sprintf(ERROR_58_HINTS, 'list', $sub);
      }
      else {
          $code .= qq{
              # An empty list, or a single undef is failure
              if (! \@results or (\@results == 1 and ! defined \$results[0])) {
                  $die;
              }
          }
      }
  
      # Tidy up the end of our wantarray call.
  
      $code .= qq[
              return \@results;
          }
      ];
  
  
      # Otherwise, we're in scalar context.
      # We're never in a void context, since we have to look
      # at the result.
  
      $code .= qq{
          my \$retval  = $call(@argv);
          my \$context = "scalar";
      };
  
      if ( $hints and ( ref($hints->{scalar} ) || "" ) eq 'CODE' ) {
  
          # We always call code refs directly, since that always
          # works in 5.8.x, and always works in 5.10.1
  
          return $code .= qq{
              if ( \$hints->{scalar}->(\$retval) ) { $die };
              $retval_action
              return \$retval;
          };
  
      }
      elsif (PERL510 and $hints) {
          return $code . qq{
  
              if ( \$retval ~~ \$hints->{scalar} ) { $die };
              $retval_action
              return \$retval;
          };
      }
      elsif ( $hints ) {
          croak sprintf(ERROR_58_HINTS, 'scalar', $sub);
      }
  
      return $code .
      ( $use_defined_or ? qq{
  
          $die if not defined \$retval;
          $retval_action
          return \$retval;
  
      } : qq{
  
          $retval_action
          return \$retval || $die;
  
      } ) ;
  
  }
  
  # This returns the old copy of the sub, so we can
  # put it back at end of scope.
  
  # TODO : Check to make sure prototypes are restored correctly.
  
  # TODO: Taking a huge list of arguments is awful.  Rewriting to
  #       take a hash would be lovely.
  
  # TODO - BACKCOMPAT - This is not yet compatible with 5.10.0
  
  sub _make_fatal {
      my($class, $sub, $pkg, $void, $lexical, $filename, $insist, $install_subs) = @_;
      my($code, $sref, $proto, $core, $call, $hints, $cache, $cache_type);
      my $ini = $sub;
      my $name = $sub;
  
  
      if (index($sub, '::') == -1) {
          $sub = "${pkg}::$sub";
          if (substr($name, 0, 1) eq '&') {
              $name = substr($name, 1);
          }
      } else {
          $name =~ s/.*:://;
      }
  
  
      # Figure if we're using lexical or package semantics and
      # twiddle the appropriate bits.
  
      if (not $lexical) {
          $Package_Fatal{$sub} = 1;
      }
  
      # TODO - We *should* be able to do skipping, since we know when
      # we've lexicalised / unlexicalised a subroutine.
  
  
      warn  "# _make_fatal: sub=$sub pkg=$pkg name=$name void=$void\n" if $Debug;
      croak(sprintf(ERROR_BADNAME, $class, $name)) unless $name =~ /^\w+$/;
  
      if (defined(&$sub)) {   # user subroutine
  
          # NOTE: Previously we would localise $@ at this point, so
          # the following calls to eval {} wouldn't interfere with anything
          # that's already in $@.  Unfortunately, it would also stop
          # any of our croaks from triggering(!), which is even worse.
  
          # This could be something that we've fatalised that
          # was in core.
  
  	# Store the current sub in case we need to restore it.
  	$sref = \&$sub;
  
          if ( $Package_Fatal{$sub} and exists($CORE_prototype_cache{"CORE::$name"})) {
  
              # Something we previously made Fatal that was core.
              # This is safe to replace with an autodying to core
              # version.
  
              $core  = 1;
              $call  = "CORE::$name";
              $proto = $CORE_prototype_cache{$call};
  
              # We return our $sref from this subroutine later
              # on, indicating this subroutine should be placed
              # back when we're finished.
  
  
  
          } else {
  
              # If this is something we've already fatalised or played with,
              # then look-up the name of the original sub for the rest of
              # our processing.
  
              if (exists($Is_fatalised_sub{$sref})) {
                  # $sub is one of our wrappers around a CORE sub or a
                  # user sub.  Instead of wrapping our wrapper, lets just
                  # generate a new wrapper for the original sub.
                  # - NB: the current wrapper might be for a different class
                  #   than the one we are generating now (e.g. some limited
                  #   mixing between use Fatal + use autodie can occur).
                  # - Even for nested autodie, we need this as the leak guards
                  #   differ.
                  my $s = $Is_fatalised_sub{$sref};
                  if (defined($s)) {
                      # It is a wrapper for a user sub
                      $sub = $s;
                  } else {
                      # It is a wrapper for a CORE:: sub
                      $core = 1;
                      $call = "CORE::$name";
                      $proto = $CORE_prototype_cache{$call};
                  }
              }
  
              # A regular user sub, or a user sub wrapping a
              # core sub.
  
              if (!$core) {
                  # A non-CORE sub might have hints and such...
                  $proto = prototype($sref);
                  $call = '&$sref';
                  require autodie::hints;
  
                  $hints = autodie::hints->get_hints_for( $sref );
  
                  # If we've insisted on hints, but don't have them, then
                  # bail out!
  
                  if ($insist and not $hints) {
                      croak(sprintf(ERROR_NOHINTS, $name));
                  }
  
                  # Otherwise, use the default hints if we don't have
                  # any.
  
                  $hints ||= autodie::hints::DEFAULT_HINTS();
              }
  
          }
  
      } elsif ($sub eq $ini && $sub !~ /^CORE::GLOBAL::/) {
          # Stray user subroutine
          croak(sprintf(ERROR_NOTSUB,$sub));
  
      } elsif ($name eq 'system') {
  
          # If we're fatalising system, then we need to load
          # helper code.
  
          # The business with $E is to avoid clobbering our caller's
          # $@, and to avoid $@ being localised when we croak.
  
          my $E;
  
          {
              local $@;
  
              eval {
                  require IPC::System::Simple; # Only load it if we need it.
                  require autodie::exception::system;
              };
              $E = $@;
          }
  
          if ($E) { croak ERROR_NO_IPC_SYS_SIMPLE; }
  
          # Make sure we're using a recent version of ISS that actually
          # support fatalised system.
          if ($IPC::System::Simple::VERSION < MIN_IPC_SYS_SIMPLE_VER) {
              croak sprintf(
              ERROR_IPC_SYS_SIMPLE_OLD, MIN_IPC_SYS_SIMPLE_VER,
              $IPC::System::Simple::VERSION
              );
          }
  
          $call = 'CORE::system';
          $core = 1;
  
      } elsif ($name eq 'exec') {
          # Exec doesn't have a prototype.  We don't care.  This
          # breaks the exotic form with lexical scope, and gives
          # the regular form a "do or die" behavior as expected.
  
          $call = 'CORE::exec';
          $core = 1;
  
      } else {            # CORE subroutine
          $call = "CORE::$name";
          if (exists($CORE_prototype_cache{$call})) {
              $proto = $CORE_prototype_cache{$call};
          } else {
              my $E;
              {
                  local $@;
                  $proto = eval { prototype $call };
                  $E = $@;
              }
              croak(sprintf(ERROR_NOT_BUILT,$name)) if $E;
              croak(sprintf(ERROR_CANT_OVERRIDE,$name)) if not defined $proto;
              $CORE_prototype_cache{$call} = $proto;
          }
          $core = 1;
      }
  
      # TODO: This caching works, but I don't like using $void and
      # $lexical as keys.  In particular, I suspect our code may end up
      # wrapping already wrapped code when autodie and Fatal are used
      # together.
  
      # NB: We must use '$sub' (the name plus package) and not
      # just '$name' (the short name) here.  Failing to do so
      # results code that's in the wrong package, and hence has
      # access to the wrong package filehandles.
  
      $cache = $Cached_fatalised_sub{$class}{$sub};
      if ($lexical) {
          $cache_type = CACHE_AUTODIE_LEAK_GUARD;
      } else {
          $cache_type = CACHE_FATAL_WRAPPER;
          $cache_type = CACHE_FATAL_VOID if $void;
      }
  
      if (my $subref = $cache->{$cache_type}) {
          $install_subs->{$name} = $subref;
          return $sref;
      }
  
      # If our subroutine is reusable (ie, not package depdendent),
      # then check to see if we've got a cached copy, and use that.
      # See RT #46984. (Thanks to Niels Thykier for being awesome!)
  
      if ($core && exists $reusable_builtins{$call}) {
          # For non-lexical subs, we can just use this cache directly
          # - for lexical variants, we need a leak guard as well.
          $code = $reusable_builtins{$call}{$lexical};
          if (!$lexical && defined($code)) {
              $install_subs->{$name} = $code;
              return $sref;
          }
      }
  
      if (!($lexical && $core) && !defined($code)) {
          # No code available, generate it now.
          my $wrapper_pkg = $pkg;
          $wrapper_pkg = undef if (exists($reusable_builtins{$call}));
          $code = $class->_compile_wrapper($wrapper_pkg, $core, $call, $name,
                                           $void, $lexical, $sub, $sref,
                                           $hints, $proto);
          if (!defined($wrapper_pkg)) {
              # cache it so we don't recompile this part again
              $reusable_builtins{$call}{$lexical} = $code;
          }
      }
  
      # Now we need to wrap our fatalised sub inside an itty bitty
      # closure, which can detect if we've leaked into another file.
      # Luckily, we only need to do this for lexical (autodie)
      # subs.  Fatal subs can leak all they want, it's considered
      # a "feature" (or at least backwards compatible).
  
      # TODO: Cache our leak guards!
  
      # TODO: This is pretty hairy code.  A lot more tests would
      # be really nice for this.
  
      my $installed_sub = $code;
  
      if ($lexical) {
          $installed_sub = $class->_make_leak_guard($filename, $code, $sref, $call,
                                                    $pkg, $proto);
      }
  
      $cache->{$cache_type} = $code;
  
      $install_subs->{$name} = $installed_sub;
  
      # Cache that we've now overridden this sub.  If we get called
      # again, we may need to find that find subroutine again (eg, for hints).
  
      $Is_fatalised_sub{$installed_sub} = $sref;
  
      return $sref;
  
  }
  
  # This subroutine exists primarily so that child classes can override
  # it to point to their own exception class.  Doing this is significantly
  # less complex than overriding throw()
  
  sub exception_class { return "autodie::exception" };
  
  {
      my %exception_class_for;
      my %class_loaded;
  
      sub throw {
          my ($class, @args) = @_;
  
          # Find our exception class if we need it.
          my $exception_class =
               $exception_class_for{$class} ||= $class->exception_class;
  
          if (not $class_loaded{$exception_class}) {
              if ($exception_class =~ /[^\w:']/) {
                  confess "Bad exception class '$exception_class'.\nThe '$class->exception_class' method wants to use $exception_class\nfor exceptions, but it contains characters which are not word-characters or colons.";
              }
  
              # Alas, Perl does turn barewords into modules unless they're
              # actually barewords.  As such, we're left doing a string eval
              # to make sure we load our file correctly.
  
              my $E;
  
              {
                  local $@;   # We can't clobber $@, it's wrong!
                  my $pm_file = $exception_class . ".pm";
                  $pm_file =~ s{ (?: :: | ' ) }{/}gx;
                  eval { require $pm_file };
                  $E = $@;    # Save $E despite ending our local.
              }
  
              # We need quotes around $@ to make sure it's stringified
              # while still in scope.  Without them, we run the risk of
              # $@ having been cleared by us exiting the local() block.
  
              confess "Failed to load '$exception_class'.\nThis may be a typo in the '$class->exception_class' method,\nor the '$exception_class' module may not exist.\n\n $E" if $E;
  
              $class_loaded{$exception_class}++;
  
          }
  
          return $exception_class->new(@args);
      }
  }
  
  # Creates and returns a leak guard (with prototype if needed).
  sub _make_leak_guard {
      my ($class, $filename, $wrapped_sub, $orig_sub, $call, $pkg, $proto) = @_;
  
      # The leak guard is rather lengthly (in fact it makes up the most
      # of _make_leak_guard).  It is possible to split it into a large
      # "generic" part and a small wrapper with call-specific
      # information.  This was done in v2.19 and profiling suggested
      # that we ended up using a substantial amount of runtime in "goto"
      # between the leak guard(s) and the final sub.  Therefore, the two
      # parts were merged into one to reduce the runtime overhead.
  
      my $leak_guard = sub {
          my $caller_level = 0;
          my $caller;
  
          while ( ($caller = (caller $caller_level)[1]) =~ m{^\(eval \d+\)$} ) {
  
              # If our filename is actually an eval, and we
              # reach it, then go to our autodying code immediatately.
  
              last if ($caller eq $filename);
              $caller_level++;
          }
  
          # We're now out of the eval stack.
  
          if ($caller eq $filename) {
              # No leak, call the wrapper.  NB: In this case, it doesn't
              # matter if it is a CORE sub or not.
              if (!defined($wrapped_sub)) {
                  # CORE sub that we were too lazy to compile when we
                  # created this leak guard.
                  die "$call is not CORE::<something>"
                      if substr($call, 0, 6) ne 'CORE::';
  
                  my $name = substr($call, 6);
                  my $sub = $name;
                  my $lexical = 1;
                  my $wrapper_pkg = $pkg;
                  my $code;
                  if (exists($reusable_builtins{$call})) {
                      $code = $reusable_builtins{$call}{$lexical};
                      $wrapper_pkg = undef;
                  }
                  if (!defined($code)) {
                      $code = $class->_compile_wrapper($wrapper_pkg,
                                                       1, # core
                                                       $call,
                                                       $name,
                                                       0, # void
                                                       $lexical,
                                                       $sub,
                                                       undef, # subref (not used for core)
                                                       undef, # hints (not used for core)
                                                       $proto);
  
                      if (!defined($wrapper_pkg)) {
                          # cache it so we don't recompile this part again
                          $reusable_builtins{$call}{$lexical} = $code;
                      }
                  }
                  # As $wrapped_sub is "closed over", updating its value will
                  # be "remembered" for the next call.
                  $wrapped_sub = $code;
              }
              goto $wrapped_sub;
          }
  
          # We leaked, time to call the original function.
          # - for non-core functions that will be $orig_sub
          # - for CORE functions, $orig_sub may be a trampoline
          goto $orig_sub if defined($orig_sub);
  
          # We are wrapping a CORE sub and we do not have a trampoline
          # yet.
          #
          # If we've cached a trampoline, then use it.  Usually only
          # resuable subs will have cache hits, but non-reusuably ones
          # can get it as well in (very) rare cases.  It is mostly in
          # cases where a package uses autodie multiple times and leaks
          # from multiple places.  Possibly something like:
          #
          #  package Pkg::With::LeakyCode;
          #  sub a {
          #      use autodie;
          #      code_that_leaks();
          #  }
          #
          #  sub b {
          #      use autodie;
          #      more_leaky_code();
          #  }
          #
          # Note that we use "Fatal" as package name for reusable subs
          # because A) that allows us to trivially re-use the
          # trampolines as well and B) because the reusable sub is
          # compiled into "package Fatal" as well.
  
          $pkg = 'Fatal' if exists $reusable_builtins{$call};
          $orig_sub = $Trampoline_cache{$pkg}{$call};
  
          if (not $orig_sub) {
              # If we don't have a trampoline, we need to build it.
              #
              # We only generate trampolines when we need them, and
              # we can cache them by subroutine + package.
              #
              # As $orig_sub is "closed over", updating its value will
              # be "remembered" for the next call.
  
              $orig_sub = _make_core_trampoline($call, $pkg, $proto);
  
              # We still cache it despite remembering it in $orig_sub as
              # well.  In particularly, we rely on this to avoid
              # re-compiling the reusable trampolines.
              $Trampoline_cache{$pkg}{$call} = $orig_sub;
          }
  
          # Bounce to our trampoline, which takes us to our core sub.
          goto $orig_sub;
      };  # <-- end of leak guard
  
      # If there is a prototype on the original sub, copy it to the leak
      # guard.
      if (defined $proto) {
          # The "\&" may appear to be redundant but set_prototype
          # croaks when it is removed.
          set_prototype(\&$leak_guard, $proto);
      }
  
      return $leak_guard;
  }
  
  # Create a trampoline for calling a core sub.  Essentially, a tiny sub
  # that figures out how we should be calling our core sub, puts in the
  # arguments in the right way, and bounces our control over to it.
  #
  # If we could use `goto &` on core builtins, we wouldn't need this.
  sub _make_core_trampoline {
      my ($call, $pkg, $proto_str) = @_;
      my $trampoline_code = 'sub {';
      my $trampoline_sub;
      my @protos = fill_protos($proto_str);
  
      # TODO: It may be possible to combine this with write_invocation().
  
      foreach my $proto (@protos) {
          local $" = ", ";    # So @args is formatted correctly.
          my ($count, @args) = @$proto;
          if (@args && $args[-1] =~ m/[@#]_/) {
              $trampoline_code .= qq/
                  if (\@_ >= $count) {
                      return $call(@args);
                  }
               /;
          } else {
              $trampoline_code .= qq<
                  if (\@_ == $count) {
                      return $call(@args);
                  }
               >;
          }
      }
  
      $trampoline_code .= qq< Carp::croak("Internal error in Fatal/autodie.  Leak-guard failure"); } >;
      my $E;
  
      {
          local $@;
          $trampoline_sub = eval "package $pkg;\n $trampoline_code"; ## no critic
          $E = $@;
      }
      die "Internal error in Fatal/autodie: Leak-guard installation failure: $E"
          if $E;
  
      return $trampoline_sub;
  }
  
  sub _compile_wrapper {
      my ($class, $wrapper_pkg, $core, $call, $name, $void, $lexical, $sub, $sref, $hints, $proto) = @_;
      my $real_proto = '';
      my @protos;
      my $code;
      if (defined $proto) {
          $real_proto = " ($proto)";
      } else {
          $proto = '@';
      }
  
      @protos = fill_protos($proto);
      $code = qq[
          sub$real_proto {
      ];
  
      if (!$lexical) {
          $code .= q[
             local($", $!) = (', ', 0);
          ];
      }
  
      # Don't have perl whine if exec fails, since we'll be handling
      # the exception now.
      $code .= "no warnings qw(exec);\n" if $call eq "CORE::exec";
  
      $code .= $class->_write_invocation($core, $call, $name, $void, $lexical,
                                         $sub, $sref, @protos);
      $code .= "}\n";
      warn $code if $Debug;
  
      # I thought that changing package was a monumental waste of
      # time for CORE subs, since they'll always be the same.  However
      # that's not the case, since they may refer to package-based
      # filehandles (eg, with open).
      #
      # The %reusable_builtins hash defines ones we can aggressively
      # cache as they never depend upon package-based symbols.
  
      my $E;
  
      {
          no strict 'refs'; ## no critic # to avoid: Can't use string (...) as a symbol ref ...
          local $@;
          if (defined($wrapper_pkg)) {
              $code = eval("package $wrapper_pkg; require Carp; $code");  ## no critic
          } else {
              $code = eval("require Carp; $code");  ## no critic
  
          }
          $E = $@;
      }
  
      if (not $code) {
          my $true_name = $core ? $call : $sub;
          croak("Internal error in autodie/Fatal processing $true_name: $E");
      }
      return $code;
  }
  
  # For some reason, dying while replacing our subs doesn't
  # kill our calling program.  It simply stops the loading of
  # autodie and keeps going with everything else.  The _autocroak
  # sub allows us to die with a vengeance.  It should *only* ever be
  # used for serious internal errors, since the results of it can't
  # be captured.
  
  sub _autocroak {
      warn Carp::longmess(@_);
      exit(255);  # Ugh!
  }
  
  1;
  
  __END__
  
  =head1 NAME
  
  Fatal - Replace functions with equivalents which succeed or die
  
  =head1 SYNOPSIS
  
      use Fatal qw(open close);
  
      open(my $fh, "<", $filename);  # No need to check errors!
  
      use File::Copy qw(move);
      use Fatal qw(move);
  
      move($file1, $file2); # No need to check errors!
  
      sub juggle { . . . }
      Fatal->import('juggle');
  
  =head1 BEST PRACTICE
  
  B<Fatal has been obsoleted by the new L<autodie> pragma.> Please use
  L<autodie> in preference to C<Fatal>.  L<autodie> supports lexical scoping,
  throws real exception objects, and provides much nicer error messages.
  
  The use of C<:void> with Fatal is discouraged.
  
  =head1 DESCRIPTION
  
  C<Fatal> provides a way to conveniently replace
  functions which normally return a false value when they fail with
  equivalents which raise exceptions if they are not successful.  This
  lets you use these functions without having to test their return
  values explicitly on each call.  Exceptions can be caught using
  C<eval{}>.  See L<perlfunc> and L<perlvar> for details.
  
  The do-or-die equivalents are set up simply by calling Fatal's
  C<import> routine, passing it the names of the functions to be
  replaced.  You may wrap both user-defined functions and overridable
  CORE operators (except C<exec>, C<system>, C<print>, or any other
  built-in that cannot be expressed via prototypes) in this way.
  
  If the symbol C<:void> appears in the import list, then functions
  named later in that import list raise an exception only when
  these are called in void context--that is, when their return
  values are ignored.  For example
  
      use Fatal qw/:void open close/;
  
      # properly checked, so no exception raised on error
      if (not open(my $fh, '<', '/bogotic') {
          warn "Can't open /bogotic: $!";
      }
  
      # not checked, so error raises an exception
      close FH;
  
  The use of C<:void> is discouraged, as it can result in exceptions
  not being thrown if you I<accidentally> call a method without
  void context.  Use L<autodie> instead if you need to be able to
  disable autodying/Fatal behaviour for a small block of code.
  
  =head1 DIAGNOSTICS
  
  =over 4
  
  =item Bad subroutine name for Fatal: %s
  
  You've called C<Fatal> with an argument that doesn't look like
  a subroutine name, nor a switch that this version of Fatal
  understands.
  
  =item %s is not a Perl subroutine
  
  You've asked C<Fatal> to try and replace a subroutine which does not
  exist, or has not yet been defined.
  
  =item %s is neither a builtin, nor a Perl subroutine
  
  You've asked C<Fatal> to replace a subroutine, but it's not a Perl
  built-in, and C<Fatal> couldn't find it as a regular subroutine.
  It either doesn't exist or has not yet been defined.
  
  =item Cannot make the non-overridable %s fatal
  
  You've tried to use C<Fatal> on a Perl built-in that can't be
  overridden, such as C<print> or C<system>, which means that
  C<Fatal> can't help you, although some other modules might.
  See the L</"SEE ALSO"> section of this documentation.
  
  =item Internal error: %s
  
  You've found a bug in C<Fatal>.  Please report it using
  the C<perlbug> command.
  
  =back
  
  =head1 BUGS
  
  C<Fatal> clobbers the context in which a function is called and always
  makes it a scalar context, except when the C<:void> tag is used.
  This problem does not exist in L<autodie>.
  
  "Used only once" warnings can be generated when C<autodie> or C<Fatal>
  is used with package filehandles (eg, C<FILE>).  It's strongly recommended
  you use scalar filehandles instead.
  
  =head1 AUTHOR
  
  Original module by Lionel Cons (CERN).
  
  Prototype updates by Ilya Zakharevich <ilya@math.ohio-state.edu>.
  
  L<autodie> support, bugfixes, extended diagnostics, C<system>
  support, and major overhauling by Paul Fenwick <pjf@perltraining.com.au>
  
  =head1 LICENSE
  
  This module is free software, you may distribute it under the
  same terms as Perl itself.
  
  =head1 SEE ALSO
  
  L<autodie> for a nicer way to use lexical Fatal.
  
  L<IPC::System::Simple> for a similar idea for calls to C<system()>
  and backticks.
  
  =for Pod::Coverage exception_class fill_protos one_invocation throw write_invocation ERROR_NO_IPC_SYS_SIMPLE LEXICAL_TAG
  
  =cut
FATAL

$fatpacked{"Getopt/Lucid.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'GETOPT_LUCID';
  use 5.006;
  use strict;
  use warnings;
  package Getopt::Lucid;
  # ABSTRACT: Clear, readable syntax for command line processing
  our $VERSION = '1.05'; # VERSION
  
  our @EXPORT_OK = qw(Switch Counter Param List Keypair);
  our %EXPORT_TAGS = ( all => [ @EXPORT_OK ] );
  our @ISA = qw( Exporter );
  
  use Carp;
  use Exporter ();
  use Getopt::Lucid::Exception;
  use Storable 2.16 qw(dclone);
  
  # Definitions
  my $VALID_STARTCHAR = "a-zA-Z0-9";
  my $VALID_CHAR      = "a-zA-Z0-9_-";
  my $VALID_LONG      = qr/--[$VALID_STARTCHAR][$VALID_CHAR]*/;
  my $VALID_SHORT     = qr/-[$VALID_STARTCHAR]/;
  my $VALID_BARE      = qr/[$VALID_STARTCHAR][$VALID_CHAR]*/;
  my $VALID_NAME      = qr/$VALID_LONG|$VALID_SHORT|$VALID_BARE/;
  my $SHORT_BUNDLE    = qr/-[$VALID_STARTCHAR]{2,}/;
  my $NEGATIVE        = qr/(?:--)?no-/;
  
  my @valid_keys = qw( name type default nocase valid needs canon );
  my @valid_types = qw( switch counter parameter list keypair);
  
  sub Switch  {
      return bless { name => shift, type => 'switch' },
                   "Getopt::Lucid::Spec";
  }
  sub Counter {
      return bless { name => shift, type => 'counter' },
                   "Getopt::Lucid::Spec";
  }
  sub Param   {
      my $self = { name => shift, type => 'parameter' };
      $self->{valid} = shift if @_;
      return bless $self, "Getopt::Lucid::Spec";
  }
  sub List    {
      my $self = { name => shift, type => 'list' };
      $self->{valid} = shift if @_;
      return bless $self, "Getopt::Lucid::Spec";
  }
  sub Keypair {
      my $self = { name => shift, type => 'keypair' };
      $self->{valid} = [ @_ ] if scalar @_;
      return bless $self, "Getopt::Lucid::Spec";
  }
  
  package
    Getopt::Lucid::Spec;
  $Getopt::Lucid::Spec::VERSION = $Getopt::Lucid::VERSION;
  
  # alternate way to specify validation
  sub valid {
      my $self = shift;
      Getopt::Lucid::throw_spec("valid() is not supported for '$self->{type}' options")
        unless grep { $self->{type} eq $_ } qw/parameter list keypair/;
      $self->{valid} = $self->{type} eq 'keypair' ? [ @_ ] : shift;
      return $self;
  }
  
  sub default {
      my $self = shift;
      my $type = $self->{type};
      if ($self->{type} eq 'keypair') {
          if (ref($_[0]) eq 'HASH') {
              $self->{default} = shift;
          }
          elsif ( @_ % 2 == 0 ) {
              $self->{default} = { @_ };
          }
          else {
              $self->{default} = []; # will cause an exception later
          }
      }
      elsif ( $self->{type} eq 'list' ) {
          $self->{default} = [ @_ ];
      }
      else {
          $self->{default} = shift;
      }
      return $self
  };
  
  sub anycase { my $self = shift; $self->{nocase}=1; return $self };
  
  sub needs { my $self = shift; $self->{needs}=[@_]; return $self };
  
  package Getopt::Lucid;
  
  #--------------------------------------------------------------------------#
  # new()
  #--------------------------------------------------------------------------#
  
  my @params = qw/strict target/;
  
  sub new {
      my ($class, $spec, $target) = @_;
      my $args = ref($_[-1]) eq 'HASH' ? pop(@_) : {};
      $args->{target} = ref($target) eq 'ARRAY' ? $target : \@ARGV;
      my $self = {};
      $self->{$_} = $args->{$_} for @params;
      $self->{raw_spec} = $spec;
      bless ($self, ref($class) ? ref($class) : $class);
      throw_usage("Getopt::Lucid->new() requires an option specification array reference")
          unless ref($self->{raw_spec}) eq 'ARRAY';
      _parse_spec($self);
      _set_defaults($self);
      $self->{options} = {};
      $self->{parsed} = [];
      $self->{seen}{$_} = 0 for keys %{$self->{spec}};
      return $self;
  }
  
  #--------------------------------------------------------------------------#
  # append_defaults()
  #--------------------------------------------------------------------------#
  
  sub append_defaults {
      my $self = shift;
      my %append =
          ref $_[0] eq 'HASH' ? %{+shift} :
          (@_ % 2 == 0) ? @_ :
          throw_usage("Argument to append_defaults() must be a hash or hash reference");
      for my $name ( keys %{$self->{spec}} ) {
          my $spec = $self->{spec}{$name};
          my $strip = $self->{strip}{$name};
          next unless exists $append{$strip};
          for ( $spec->{type} ) {
              /switch|parameter/ && do {
                  $self->{default}{$strip} = $append{$strip};
                  last;
              };
              /counter/ && do {
                  $self->{default}{$strip} += $append{$strip};
                  last;
              };
              /list/ && do {
                  throw_usage("Option '$strip' in append_defaults() must be scalar or array reference")
                      if ref($append{$strip}) && ref($append{$strip}) ne 'ARRAY';
                  $append{$strip} = ref($append{$strip}) eq 'ARRAY'
                      ? dclone( $append{$strip} )
                      : [ $append{$strip} ] ;
                  push @{$self->{default}{$strip}}, @{$append{$strip}};
                  last;
              };
              /keypair/ && do {
                  throw_usage("Option '$strip' in append_defaults() must be scalar or hash reference")
                      if ref($append{$strip}) && ref($append{$strip}) ne 'HASH';
                  $self->{default}{$strip} = {
                      %{$self->{default}{$strip}},
                      %{$append{$strip}},
                  };
                  last;
              };
          }
          throw_spec("Default '$spec->{canon}' = '$self->{default}{$strip}' fails to validate")
            unless _validate_value($self, $self->{default}{$strip}, $spec->{valid} );
      }
      _recalculate_options($self);
      return $self->options;
  }
  
  #--------------------------------------------------------------------------#
  # defaults()
  #--------------------------------------------------------------------------#
  
  sub defaults {
      my ($self) = @_;
      return %{dclone($self->{default})};
  }
  
  
  #--------------------------------------------------------------------------#
  # getopt()
  #--------------------------------------------------------------------------#
  
  sub getopt {
      my ($self,$spec,$target) = @_;
      if ( $self eq 'Getopt::Lucid' ) {
          throw_usage("Getopt::Lucid->getopt() requires an option specification array reference")
              unless ref($spec) eq 'ARRAY';
          $self = new(@_)
      }
      my (@passthrough);
      while (@{$self->{target}}) {
          my $raw = shift @{$self->{target}};
          last if $raw =~ /^--$/;
          my ($orig, $val) = _split_equals($self, $raw);
          next if _unbundle($self, $orig, $val);
          my $neg = $orig =~ s/^$NEGATIVE(.*)$/$1/ ? 1 : 0;
          my $arg = _find_arg($self, $orig);
          if ( $arg ) {
              $neg ?
                  $self->{seen}{$arg} = 0 :
                  $self->{seen}{$arg}++;
              for ($self->{spec}{$arg}{type}) {
                  /switch/    ? _switch   ($self, $arg, $val, $neg) :
                  /counter/   ? _counter  ($self, $arg, $val, $neg) :
                  /parameter/ ? _parameter($self, $arg, $val, $neg) :
                  /list/      ? _list     ($self, $arg, $val, $neg) :
                  /keypair/   ? _keypair  ($self, $arg, $val, $neg) :
                                throw_usage("can't handle type '$_'");
              }
          } else {
              throw_argv("Invalid argument: $orig")
                  if $orig =~ /^-./; # invalid if looks like it could be an arg;
              push @passthrough, $orig;
          }
      }
      _recalculate_options($self);
      @{$self->{target}} = (@passthrough, @{$self->{target}});
      return $self;
  }
  
  BEGIN { *getopts = \&getopt }; # handy alias
  
  #--------------------------------------------------------------------------#
  # validate
  #--------------------------------------------------------------------------#
  
  sub validate {
    my ($self, $arg) = @_;
    throw_usage("Getopt::Lucid->validate() takes a hashref argument")
      if $arg && ref($arg) ne 'HASH';
  
    if ( $arg && exists $arg->{requires} ) {
      my $requires = $arg->{requires};
      throw_usage("'validate' argument 'requires' must be an array reference")
        if $requires && ref($requires) ne 'ARRAY';
      for my $p ( @$requires ) {
          throw_argv("Required option '$self->{spec}{$p}{canon}' not found")
              if ( ! $self->{seen}{$p} );
      }
    }
  
    _check_prereqs($self);
  
    return $self;
  }
  
  #--------------------------------------------------------------------------#
  # merge_defaults()
  #--------------------------------------------------------------------------#
  
  sub merge_defaults {
      my $self = shift;
      my %merge =
          ref $_[0] eq 'HASH' ? %{+shift} :
          (@_ % 2 == 0) ? @_ :
          throw_usage("Argument to merge_defaults() must be a hash or hash reference");
      for my $name ( keys %{$self->{spec}} ) {
          my $spec = $self->{spec}{$name};
          my $strip = $self->{strip}{$name};
          next unless exists $merge{$strip};
          for ( $self->{spec}{$name}{type} ) {
              /switch|counter|parameter/ && do {
                  $self->{default}{$strip} = $merge{$strip};
                  last;
              };
              /list/ && do {
                  throw_usage("Option '$strip' in merge_defaults() must be scalar or array reference")
                      if ref($merge{$strip}) && ref($merge{$strip}) ne 'ARRAY';
                  $merge{$strip} = ref($merge{$strip}) eq 'ARRAY'
                      ? dclone( $merge{$strip} )
                      : [ $merge{$strip} ] ;
                  $self->{default}{$strip} = $merge{$strip};
                  last;
              };
              /keypair/ && do {
                  throw_usage("Option '$strip' in merge_defaults() must be scalar or hash reference")
                      if ref($merge{$strip}) && ref($merge{$strip}) ne 'HASH';
                  $self->{default}{$strip} = dclone($merge{$strip});
                  last;
              };
          }
          throw_spec("Default '$spec->{canon}' = '$self->{default}{$strip}' fails to validate")
            unless _validate_value($self, $self->{default}{$strip}, $spec->{valid} );
      }
      _recalculate_options($self);
      return $self->options;
  }
  
  #--------------------------------------------------------------------------#
  # names()
  #--------------------------------------------------------------------------#
  
  sub names {
      my ($self) = @_;
      return values %{$self->{strip}};
  }
  
  
  #--------------------------------------------------------------------------#
  # options()
  #--------------------------------------------------------------------------#
  
  sub options {
      my ($self) = @_;
      return %{dclone($self->{options})};
  }
  
  #--------------------------------------------------------------------------#
  # replace_defaults()
  #--------------------------------------------------------------------------#
  
  sub replace_defaults {
      my $self = shift;
      my %replace =
          ref $_[0] eq 'HASH' ? %{+shift} :
          (@_ % 2 == 0) ? @_ :
          throw_usage("Argument to replace_defaults() must be a hash or hash reference");
      for my $name ( keys %{$self->{spec}} ) {
          my $spec = $self->{spec}{$name};
          my $strip = $self->{strip}{$name};
          for ( $self->{spec}{$name}{type} ) {
              /switch|counter/ && do {
                  $self->{default}{$strip} = $replace{$strip} || 0;
                  last;
              };
              /parameter/ && do {
                  $self->{default}{$strip} = $replace{$strip};
                  last;
              };
              /list/ && do {
                  throw_usage("Option '$strip' in replace_defaults() must be scalar or array reference")
                      if ref($replace{$strip}) && ref($replace{$strip}) ne 'ARRAY';
                  if ( exists $replace{$strip} ) {
                      $replace{$strip} = ref($replace{$strip}) eq 'ARRAY' ?
                                         $replace{$strip} : [ $replace{$strip} ];
                  } else {
                      $replace{$strip} = [];
                  }
                  $self->{default}{$strip} = dclone($replace{$strip});
                  last;
              };
              /keypair/ && do {
                  throw_usage("Option '$strip' in replace_defaults() must be scalar or hash reference")
                      if ref($replace{$strip}) && ref($replace{$strip}) ne 'HASH';
                  $replace{$strip} = {} unless exists $replace{$strip};
                  $self->{default}{$strip} = dclone($replace{$strip});
                  last;
              };
          }
          throw_spec("Default '$spec->{canon}' = '$self->{default}{$strip}' fails to validate")
            unless _validate_value($self, $self->{default}{$strip}, $spec->{valid} );
      }
      _recalculate_options($self);
      return $self->options;
  }
  
  #--------------------------------------------------------------------------#
  # reset_defaults()
  #--------------------------------------------------------------------------#
  
  sub reset_defaults {
      my ($self) = @_;
      _set_defaults($self);
      _recalculate_options($self);
      return $self->options;
  }
  
  #--------------------------------------------------------------------------#
  # _check_prereqs()
  #--------------------------------------------------------------------------#
  
  sub _check_prereqs {
      my ($self) = @_;
      for my $key ( keys %{$self->{seen}} ) {
          next unless $self->{seen}{$key};
          next unless exists $self->{spec}{$key}{needs};
          for (@{$self->{spec}{$key}{needs}}) {
              throw_argv("Option '$self->{spec}{$key}{canon}' ".
                         "requires option '$self->{spec}{$_}{canon}'")
                  unless $self->{seen}{$_};
          }
      }
  }
  
  #--------------------------------------------------------------------------#
  # _counter()
  #--------------------------------------------------------------------------#
  
  sub _counter {
      my ($self, $arg, $val, $neg) = @_;
      throw_argv("Counter option can't take a value: $self->{spec}{$arg}{canon}=$val")
          if defined $val;
      push @{$self->{parsed}}, [ $arg, 1, $neg ];
  }
  
  #--------------------------------------------------------------------------#
  # _find_arg()
  #--------------------------------------------------------------------------#
  
  sub _find_arg {
      my ($self, $arg) = @_;
  
      $arg =~ s/^-*// unless $self->{strict};
      return $self->{alias_hr}{$arg} if exists $self->{alias_hr}{$arg};
  
      for ( keys %{$self->{alias_nocase}} ) {
          return $self->{alias_nocase}{$_} if $arg =~ /^$_$/i;
      }
  
      return;
  }
  
  #--------------------------------------------------------------------------#
  # _keypair()
  #--------------------------------------------------------------------------#
  
  sub _keypair {
      my ($self, $arg, $val, $neg) = @_;
      my ($key, $data);
      if ($neg) {
          $key = $val;
      }
      else {
          my $value = defined $val ? $val : shift @{$self->{target}};
          if (! defined $val && ! defined $value) {
              throw_argv("Option '$self->{spec}{$arg}{canon}' requires a value");
          }
  
          throw_argv("Badly formed keypair for '$self->{spec}{$arg}{canon}'")
              unless $value =~ /[^=]+=.+/;
          ($key, $data) = ( $value =~ /^([^=]*)=(.*)$/ ) ;
          throw_argv("Invalid keypair '$self->{spec}{$arg}{canon}': $key => $data")
              unless _validate_value($self, { $key => $data },
                                 $self->{spec}{$arg}{valid});
      }
      push @{$self->{parsed}}, [ $arg, [ $key, $data ], $neg ];
  }
  
  #--------------------------------------------------------------------------#
  # _list()
  #--------------------------------------------------------------------------#
  
  sub _list {
      my ($self, $arg, $val, $neg) = @_;
      my $value;
      if ($neg) {
          $value = $val;
      }
      else {
          $value = defined $val ? $val : shift @{$self->{target}};
          if (! defined $val) {
              if (! defined $value) {
                  throw_argv("Option '$self->{spec}{$arg}{canon}' requires a value");
              }
              $value =~ s/^$NEGATIVE(.*)$/$1/;
          }
  
          throw_argv("Ambiguous value for $self->{spec}{$arg}{canon} could be option: $value")
              if ! defined $val and _find_arg($self, $value);
          throw_argv("Invalid list option $self->{spec}{$arg}{canon} = $value")
              unless _validate_value($self, $value, $self->{spec}{$arg}{valid});
      }
      push @{$self->{parsed}}, [ $arg, $value, $neg ];
  }
  
  #--------------------------------------------------------------------------#
  # _parameter()
  #--------------------------------------------------------------------------#
  
  sub _parameter {
      my ($self, $arg, $val, $neg) = @_;
      my $value;
      if ($neg) {
          throw_argv("Negated parameter option can't take a value: $self->{spec}{$arg}{canon}=$val")
              if defined $val;
      }
      else {
          $value = defined $val ? $val : shift @{$self->{target}};
          if (! defined $val) {
              if (! defined $value) {
                  throw_argv("Option '$self->{spec}{$arg}{canon}' requires a value");
              }
              $value =~ s/^$NEGATIVE(.*)$/$1/;
          }
          throw_argv("Ambiguous value for $self->{spec}{$arg}{canon} could be option: $value")
              if ! defined $val and _find_arg($self, $value);
          throw_argv("Invalid parameter $self->{spec}{$arg}{canon} = $value")
              unless _validate_value($self, $value, $self->{spec}{$arg}{valid});
      }
      push @{$self->{parsed}}, [ $arg, $value, $neg ];
  }
  
  #--------------------------------------------------------------------------#
  # _parse_spec()
  #--------------------------------------------------------------------------#
  
  sub _parse_spec {
      my ($self) = @_;
      my $spec = $self->{raw_spec};
      for my $opt ( @$spec ) {
          my $name = $opt->{name};
          my @names = split( /\|/, $name );
          $opt->{canon} = $names[0];
          _validate_spec($self,\@names,$opt);
          @names = map { s/^-*//; $_ } @names unless $self->{strict}; ## no critic
          for (@names) {
              $self->{alias_hr}{$_} = $names[0];
              $self->{alias_nocase}{$_} = $names[0]  if $opt->{nocase};
          }
          $self->{spec}{$names[0]} = $opt;
          ($self->{strip}{$names[0]} = $names[0]) =~ s/^-+//;
      }
      _validate_prereqs($self);
  }
  
  #--------------------------------------------------------------------------#
  # _recalculate_options()
  #--------------------------------------------------------------------------#
  
  sub _recalculate_options {
      my ($self) = @_;
      my %result;
      for my $k ( keys %{$self->{default}} ) {
          my $d = $self->{default}{$k};
          $result{$k} = ref($d) eq 'ARRAY' ? [ @$d ] :
                        ref($d) eq 'HASH'  ? { %$d } : $d;
      }
      for my $opt ( @{$self->{parsed}} ) {
          my ($name, $value, $neg) = @$opt;
          for ($self->{spec}{$name}{type}) {
              my $strip = $self->{strip}{$name};
              /switch/    && do {
                  $result{$strip} = $neg ? 0 : $value;
                  last;
              };
              /counter/   && do {
                  $result{$strip} = $neg ? 0 : $result{$strip} + $value;
                  last;
              };
              /parameter/ && do {
                  $result{$strip} = $neg ? "" : $value;
                  last;
              };
              /list/      && do {
                  if ($neg) {
                      $result{$strip} = $value ?
                          [ grep { $_ ne $value } @{$result{$strip}} ] :
                          [];
                  }
                  else { push @{$result{$strip}}, $value }
                  last;
              };
              /keypair/   && do {
                  if ($neg) {
                      if ($value->[0]) { delete $result{$strip}{$value->[0]} }
                      else { $result{$strip} = {} }
                  }
                  else { $result{$strip}{$value->[0]} = $value->[1]};
                  last;
              };
          }
      }
      return $self->{options} = \%result;
  }
  
  #--------------------------------------------------------------------------#
  # _regex_or_code
  #--------------------------------------------------------------------------#
  
  sub _regex_or_code {
      my ($value,$valid) = @_;
      return 1 unless defined $valid;
      if ( ref($valid) eq 'CODE' ) {
          local $_ = $value;
          return $valid->($value);
      } else {
          return $value =~ /^$valid$/;
      }
  }
  
  #--------------------------------------------------------------------------#
  # _set_defaults()
  #--------------------------------------------------------------------------#
  
  sub _set_defaults {
      my ($self) = @_;
      my %default;
      for my $k ( keys %{$self->{spec}} ) {
          my $spec = $self->{spec}{$k};
          my $d = exists ($spec->{default}) ? $spec->{default} : undef;
          my $type = $self->{spec}{$k}{type};
          my $strip = $self->{strip}{$k};
          throw_spec("Default for list '$spec->{canon}' must be array reference")
              if ( $type eq "list" && defined $d && ref($d) ne "ARRAY" );
          throw_spec("Default for keypair '$spec->{canon}' must be hash reference")
              if ( $type eq "keypair" && defined $d && ref($d) ne "HASH" );
          if (defined $d) {
            throw_spec("Default '$spec->{canon}' = '$d' fails to validate")
              unless _validate_value($self, $d, $spec->{valid});
          }
          $default{$strip} = do {
              local $_ = $type;
              /switch/    ?   (defined $d ? $d: 0)   :
              /counter/   ?   (defined $d ? $d: 0)   :
              /parameter/ ?   $d :
              /list/      ?   (defined $d ? dclone($d): [])  :
              /keypair/   ?   (defined $d ? dclone($d): {})  :
                              undef;
          };
      }
      $self->{default} = \%default;
  }
  
  #--------------------------------------------------------------------------#
  # _split_equals()
  #--------------------------------------------------------------------------#
  
  sub _split_equals {
      my ($self,$raw) = @_;
      my ($arg,$val);
      if ( $raw =~ /^($NEGATIVE?$VALID_NAME|$SHORT_BUNDLE)=(.*)/ ) {
          $arg = $1;
          $val = $2;
      } else {
          $arg = $raw;
      }
      return ($arg, $val);
  }
  
  #--------------------------------------------------------------------------#
  # _switch()
  #--------------------------------------------------------------------------#
  
  sub _switch {
      my ($self, $arg, $val, $neg) = @_;
      throw_argv("Switch can't take a value: $self->{spec}{$arg}{canon}=$val")
          if defined $val;
      if (! $neg ) {
          throw_argv("Switch used twice: $self->{spec}{$arg}{canon}")
              if $self->{seen}{$arg} > 1;
      }
      push @{$self->{parsed}}, [ $arg, 1, $neg ];
  }
  
  #--------------------------------------------------------------------------#
  # _unbundle()
  #--------------------------------------------------------------------------#
  
  sub _unbundle {
      my ($self,$arg, $val) = @_;
      if ( $arg =~ /^$SHORT_BUNDLE$/ ) {
          my @flags = split(//,substr($arg,1));
          unshift @{$self->{target}}, ("-" . pop(@flags) . "=" . $val)
              if defined $val;
          for ( reverse @flags ) {
              unshift @{$self->{target}}, "-$_";
          }
          return 1;
      }
      return 0;
  }
  
  #--------------------------------------------------------------------------#
  # _validate_prereqs()
  #--------------------------------------------------------------------------#
  
  sub _validate_prereqs {
      my ($self) = @_;
      for my $key ( keys %{$self->{spec}} ) {
          next unless exists $self->{spec}{$key}{needs};
          my $needs = $self->{spec}{$key}{needs};
          my @prereq = ref($needs) eq 'ARRAY' ? @$needs : ( $needs );
          for (@prereq) {
              throw_spec("Prerequisite '$_' for '$self->{spec}{$key}{canon}' is not recognized")
                  unless _find_arg($self,$_);
              $_ = _find_arg($self,$_);
          }
          $self->{spec}{$key}{needs} = \@prereq;
      }
  }
  
  
  #--------------------------------------------------------------------------#
  # _validate_spec()
  #--------------------------------------------------------------------------#
  
  sub _validate_spec {
      my ($self,$names,$details) = @_;
      for my $name ( @$names ) {
          my $alt_name = $name;
          $alt_name =~ s/^-*// unless $self->{strict};
          throw_spec(
              "'$name' is not a valid option name/alias"
          ) unless $name =~ /^$VALID_NAME$/;
          throw_spec(
              "'$name' is not unique"
          ) if exists $self->{alias_hr}{$alt_name};
          my $strip;
          ($strip = $name) =~ s/^-+//;
          throw_spec(
              "'$strip' conflicts with other options"
          ) if grep { $strip eq $_ } values %{$self->{strip}};
      }
      for my $key ( keys %$details ) {
          throw_spec(
              "'$key' is not a valid option specification key"
          ) unless grep { $key eq $_ } @valid_keys;
      }
      my $type = $details->{type};
      throw_spec(
          "'$type' is not a valid option type"
      ) unless grep { $type eq $_ } @valid_types;
  }
  
  #--------------------------------------------------------------------------#
  # _validate_value()
  #--------------------------------------------------------------------------#
  
  sub _validate_value {
      my ($self, $value, $valid) = @_;
      return 1 unless defined $valid;
      if ( ref($value) eq 'HASH' ) {
          my $valid_key = $valid->[0];
          my $valid_val = $valid->[1];
          while (my ($k,$v) = each %$value) {
              _regex_or_code($k, $valid_key) or return 0;
              _regex_or_code($v, $valid_val) or return 0;
          }
          return 1;
      } elsif ( ref($value) eq 'ARRAY' ) {
          for (@$value) {
              _regex_or_code($_, $valid) or return 0;
          }
          return 1;
      } else {
          return _regex_or_code($value, $valid);
      }
  }
  
  #--------------------------------------------------------------------------#
  # AUTOLOAD()
  #--------------------------------------------------------------------------#
  
  sub AUTOLOAD {
      my $self = shift;
      my $name = $Getopt::Lucid::AUTOLOAD;
      $name =~ s/.*:://;   # strip fully-qualified portion
      return if $name eq "DESTROY";
      my ($action, $maybe_opt) = $name =~ /^(get|set)_(.+)/ ;
      if ($action) {
          # look for a match
          my $opt;
          SEARCH:
          for my $known_opt ( values %{ $self->{strip} } ) {
              if ( $maybe_opt eq $known_opt ) {
                  $opt = $known_opt;
                  last SEARCH;
              }
              # try without dashes
              (my $fuzzy_opt = $known_opt) =~ s/-/_/g;
              if ( $maybe_opt eq $fuzzy_opt ) {
                  $opt = $known_opt;
                  last SEARCH;
              }
          }
  
          # throw if no valid option was found
          throw_usage("Can't $action unknown option '$maybe_opt'")
              if ! $opt;
  
          # handle the accessor if an option was found
          if ($action eq "set") {
              $self->{options}{$opt} =
                  ref($self->{options}{$opt}) eq 'ARRAY' ? [@_] :
                  ref($self->{options}{$opt}) eq 'HASH'  ? {@_} : shift;
  
          }
          my $ans = $self->{options}{$opt};
          return ref($ans) eq 'ARRAY' ? @$ans :
                 ref($ans) eq 'HASH'  ? %$ans : $ans;
      }
      my $super = "SUPER::$name";
      $self->$super(@_);
  }
  
  1; # modules must be true
  
  __END__
  
  =pod
  
  =encoding utf-8
  
  =head1 NAME
  
  Getopt::Lucid - Clear, readable syntax for command line processing
  
  =head1 VERSION
  
  version 1.05
  
  =head1 SYNOPSIS
  
     use Getopt::Lucid qw( :all );
   
     # basic option specifications with aliases
   
     @specs = (
       Switch("version|V"),
       Counter("verbose|v"),
       Param("config|C"),
       List("lib|l|I"),
       Keypair("define"),
       Switch("help|h")
     );
   
     $opt = Getopt::Lucid->getopt( \@specs )->validate;
   
     $verbosity = $opt->get_verbose;
     @libs = $opt->get_lib;
     %defs = $opt->get_define;
   
     %all_options = $opt->options;
   
     # advanced option specifications
   
     @adv_spec = (
       Param("input"),
       Param("mode")->default("tcp"),     # defaults
       Param("host")->needs("port"),      # dependencies
       Param("port")->valid(qr/\d+/),     # regex validation
       Param("config")->valid(sub { -r }),# custom validation
       Param("help")->anycase,            # case insensitivity
     );
     $opt = Getopt::Lucid->getopt( \@adv_spec );
     $opt->validate( 'requires' => ['input'] );
   
     # example with a config file
   
     $opt = Getopt::Lucid->getopt( \@adv_spec );
     use Config::Std;
     if ( -r $opt->get_config ) {
       read_config( $opt->get_config() => my %config_hash );
       $opt->merge_defaults( $config_hash{''} );
     }
  
  =head1 DESCRIPTION
  
  The goal of this module is providing good code readability and clarity of
  intent for command-line option processing.  While readability is a subjective
  standard, Getopt::Lucid relies on a more verbose, plain-English option
  specification as compared against the more symbolic approach of Getopt::Long.
  Key features include:
  
  =over
  
  =item *
  
  Five option types: switches, counters, parameters, lists, and key pairs
  
  =item *
  
  Three option styles: long, short (including bundled), and bare (without
  dashes)
  
  =item *
  
  Specification of defaults, required options and option dependencies
  
  =item *
  
  Validation of options with regexes or subroutines
  
  =item *
  
  Negation of options on the command line
  
  =item *
  
  Support for parsing any array, not just the default C<<< @ARGV >>>
  
  =item *
  
  Incorporation of external defaults (e.g. from a config file) with
  user control of precedence
  
  =back
  
  =for Pod::Coverage getopts
  
  =head1 USAGE
  
  =head2 Option Styles, Naming and "Strictness"
  
  Getopt::Lucid support three kinds of option styles: long-style ("--foo"),
  short-style ("-f") and bareword style ("foo").  Short-style options
  are automatically unbundled during command line processing if a single dash
  is followed by more than one letter (e.g. C<<< -xzf >>> becomes C<<< -x -z -f >>> ).
  
  Each option is identified in the specification with a string consisting of the
  option "name" followed by zero or more "aliases", with any alias (and each
  subsequent alias) separated by a vertical bar character.  E.g.:
  
     "lib|l|I" means name "lib", alias "l" and alias "I"
  
  Names and aliases must begin with an alphanumeric character, but subsequently
  may also include both underscore and dash.  (E.g. both "input-file" and
  "input_file" are valid.)  While names and aliases are interchangeable
  when provided on the command line, the "name" portion is used with the accessors
  for each option (see L</Accessors and Mutators>).
  
  Any of the names and aliases in the specification may be given in any of the
  three styles.  By default, Getopt::Lucid works in "magic" mode, in which option
  names or aliases may be specified with or without leading dashes, and will be
  parsed from the command line whether or not they have corresponding dashes.
  Single-character names or aliases may be read with no dash, one dash or two
  dashes.  Multi-character names or aliases must have either no dashes or two
  dashes.  E.g.:
  
  =over
  
  =item *
  
  Both "foo" and "--foo" as names in the specification may be read from
  the command line as either "--foo" or "foo"
  
  =item *
  
  The specification name "f" may be read from the command line as "--f",
  "-f", or just "f"
  
  =back
  
  In practice, this means that the specification need not use dashes, but if
  used on the command line, they will be treated appropriately.
  
  Alternatively, Getopt::Lucid can operate in "strict" mode by setting
  the CE<lt>strictE<gt> parameter to a true value.  In strict mode, option names
  and aliases may still be specified in any of the three styles, but they
  will only be parsed from the command line if they are used in exactly
  the same style.  E.g., given the name and alias "--helpE<verbar>-h", only "--help"
  and "-h" are valid for use on the command line.
  
  =head2 Option Specification Constructors
  
  Options specifications are provided to Getopt::Lucid in an array.  Entries in
  the array must be created with one of several special constructor functions
  that return a specification object.  These constructor functions may be
  imported either individually or as a group using the import tag ":all" (e.g.
  C<<< use Getopt::Lucid qw(:all); >>>).
  
  The form of the constructor is:
  
    TYPE( NAME_ARGUMENT );
  
  The constructor function name indicates the type of option.  The name argument
  is a string with the names and aliases separated by vertical bar characters.
  
  The five option specification constructors are:
  
  =head3 Switch()
  
  A trueE<sol>false value.  Defaults to false.  The appearance
  of an option of this type on the command line sets it to true.
  
  =head3 Counter()
  
  A numerical counter.  Defaults to 0.  The appearance
  of an option of this type on the command line increments the counter by one.
  
  =head3 Param()
  
  A variable taking an argument.  Defaults to "" (the empty
  string).  When an option of this type appears on the command line, the value of
  the option is set in one of two ways -- appended with an equals sign or from the
  next argument on the command line:
  
     --name=value
     --name value
  
  In the case where white space is used to separate the option name and the
  value, if the value looks like an option, an exception will be thrown:
  
     --name --value        # throws an exception
  
  =head3 List()
  
  This is like C<<< Param() >>> but arguments are pushed onto a list.
  The default list is empty.
  
  =head3 Keypair()
  
  A variable taking an argument pair, which are added
  to a hash.  Arguments are handled as with C<<< Param() >>>, but the argument itself
  must have a key and value joined by an equals sign.
  
     --name=key=value
     --name key=value
  
  =head2 Option modifiers
  
  An option specification can be further modified with the following methods,
  each of which return the object modified so that modifier chaining is
  possible.  E.g.:
  
     @spec = (
       Param("input")->default("/dev/random")->needs("output"),
       Param("output)->default("/dev/null"),
     );
  
  =head3 valid()
  
  Sets the validation parameter(s) for an option.
  
     @spec = (
       Param("port")->valid(qr/\d+/),          # regex validation
       Param("config")->valid(sub { -r }),     # custom validation
       Keypair("define")
         ->valid(\&_valid_key, \&valid_value), # keypairs take two
     );
  
  See the L</Validation> section, below, for more.
  
  =head3 default()
  
  Changes the default for the option to the argument(s) of
  C<<< default() >>>.  List and hashes can take either a list or a reference to an
  array or hash, respectively.
  
     @spec = (
       Switch("debug")->default(1),
       Counter("verbose")->default(3),
       Param("config")->default("/etc/profile"),
       List("dirs")->default(qw( /var /home )),
       Keypair("define")->default( arch => "i386" ),
     );
  
  =head3 needs()
  
  Takes as an argument a list of option names or aliases of
  dependencies.  If the option this modifies appears on the command line, each of
  the options given as an argument must appear on the command line as well or an
  exception is thrown.
  
     @spec = (
       Param("input")->needs("output"),
       Param("output),
     );
  
  =head3 anycase()
  
  Indicates that the associated option namesE<sol>aliases may appear
  on the command line in lowercase, uppercase, or any mixture of the two.  No
  argument is needed.
  
     @spec = (
       Switch("help|h")->anycase(),    # "Help", "HELP", etc.
     );
  
  =head2 Validation
  
  Validation happens in two stages.  First, individual parameters may have
  validation criteria added to them.  Second, the parsed options object may be
  validated by checking that all requirements collectively are met.
  
  =head3 Parameter validation
  
  The Param, List, and Keypair option types may be provided an optional
  validation specification.  Values provided on the command line will be
  validated according to the specification or an exception will be thrown.
  
  A validation specification can be either a regular expression, or a reference
  to a subroutine.  Keypairs take up to two validation specifiers.  The first is
  applied to keys and the second is applied to values; either can be left undef
  to ignore validation.  (More complex validation of specific values for specific
  keys must be done manually.)
  
  Validation is also applied to default values provided via the C<<< default() >>>
  modifier or later modified with C<<< append_defaults >>>, C<<< merge_defaults >>>, or
  C<<< replace_defaults >>>.  This ensures internal consistency.
  
  If no default is explicitly provided, validation is only applied if the option
  appears on the command line. (In other words, the built-in defaults are always
  considered valid if the option does not appear.)  If this is not desired, the
  C<<< required >>> option to the C<<< validate >>> method should be used to force users to
  provide an explicit value.
  
     # Must be provided and is thus always validated
     @spec = ( Param("width")->valid(qr/\d+/) );
     $opt = Getopt::Lucid->getopt(\@spec);
     $opt->validate( {requires => ['width']} );
  
  For validation subroutines, the value found on the command line is passed as
  the first element of C<<< @_ >>>, and C<<< $_ >>> is also set equal to the first element.
  (N.B. Changing C<<< $_ >>> will not change the value that is captured.)  The value
  validates if the subroutine returns a true value.
  
  For validation with regular expressions, consider using L<Regexp::Common>
  for a ready library of validation options.
  
  Older versions of Getopt::Lucid used validation arguments provided in the Spec
  constructor.  This is still supported, but is deprecated and discouraged. It
  may be removed in a future version of Getopt::Lucid.
  
     # deprecated
     Param("height", qr/\d+/)
  
  =head3 Options object validation
  
  The C<<< validate >>> method should be called on the result of C<<< getopt >>>.  This will
  check that all parameter prerequisites defined by C<<< needs >>> have been met.  It
  also takes a hashref of arguments.  The optional C<<< requires >>> argument gives an
  arrayref of parameters that must exist.
  
  The reason that object validation is done separate from C<<< getopt >>> is to allow
  for better control over different options that might be required or to allow
  some dependencies (i.e. from C<<< needs >>>) to be met via a configuration file.
  
     @spec = (
       Param("action")->needs(qw/user password/),
       Param("user"),
       Param("password"),
     );
     $opt = Getopt::Lucid->getopt(\@spec);
     $opt->merge_defaults( read_config() ); # provides 'user' & 'password'
     $opt->validate({requires => ['action']});
  
  =head2 Parsing the Command Line
  
  Technically, Getopt::Lucid scans an array for command line options, not a
  command-line string.  By default, this array is C<<< @ARGV >>> (though other arrays
  can be used -- see C<<< new() >>>), which is typically provided by the operating
  system according to system-specific rules.
  
  When Getopt::Lucid processes the array, it scans the array in order, removing
  any specified command line options and any associated arguments, and leaving
  behind any unrecognized elements in the array.  If an element consisting solely
  of two-dashes ("--") is found, array scanning is terminated at that point.
  Any options found during scanning are applied in order.  E.g.:
  
     @ARGV = qw( --lib /tmp --lib /var );
     my $opt = Getopt::Lucid->getopt( [ List("lib") ] );
     print join ", " $opt->lib;
     # prints "/tmp, /var"
  
  If an element encountered in processing begins with a dash, but is not
  recognized as a short-form or long-form option name or alias, an exception
  will be thrown.
  
  =head2 Negation
  
  Getopt::Lucid also supports negating options.  Options are negated if the
  option is specified with "no-" or "--no-" prefixed to a name or alias.  By
  default, negation clears the option:  Switch and Counter options are set to
  zero; Param options are set to ""; List and Keypair options are set to an empty
  list and empty hash, respectively. For List and Keypair options, it is also
  possible to negate a specific list element or hash key by placing an equals
  sign and the list element or key immediately after the option name:
  
     --no-lib=/tmp --no-define=arch
     # removes "/tmp" from lib and the "arch" key from define
  
  As with all options, negation is processed in order, allowing a "reset" in
  the middle of command line processing.  This may be useful for those using
  command aliases who wish to "switch off" options in the alias.  E.g, in Unix:
  
     $ alias wibble = wibble.pl --verbose
     $ wibble --no-verbose
   
     # @ARGV would contain ( "--verbose", "--no-verbose" )
  
  This also may have applications in post-processing configuration files (see
  L</Managing Defaults and Config Files>).
  
  =head2 Accessors and Mutators
  
  After processing the command-line array, the values of the options may be read
  or modified using accessorsE<sol>mutators of the form "get_NAME" and "set_NAME",
  where NAME represents the option name in the specification without any
  leading dashes. E.g.
  
     @spec = (
       Switch("--test|-t"),
       List("--lib|-L"),
       Keypair("--define|-D"),
     );
   
     $opt = Getopt::Lucid->getopt( \@spec );
     print $opt->get_test ? "True" : "False";
     $opt->set_test(1);
  
  For option names with dashes, underscores should be substituted in the accessor
  calls.  E.g.
  
     @spec = (
       Param("--input-file|-i")
     );
   
     $opt = Getopt::Lucid->getopt( \@spec );
     print $opt->get_input_file;
  
  This can create an ambiguous case if a similar option exists with underscores
  in place of dashes.  (E.g. "input_file" and "input-file".)  Users can safely
  avoid these problems by choosing to use either dashes or underscores
  exclusively and not mixing the two styles.
  
  List and Keypair options are returned as flattened lists:
  
     my @lib = $opt->get_lib;
     my %define = $opt->get_define;
  
  Using the "set_NAME" mutator is not recommended and should be used with
  caution.  No validation is performed and changes will be lost if the results of
  processing the command line array are recomputed (e.g, such as occurs if new
  defaults are applied).  List and Keypair options mutators take a list, not
  references.
  
  =head2 Managing Defaults and Config Files
  
  A typical problem for command-line option processing is the precedence
  relationship between default option values specified within the program,
  default option values stored in a configuration file or in environment
  variables, and option values specified on the command-line, particularly
  when the command-line specifies an alternate configuration file.
  
  Getopt::Lucid takes the following approach to this problem:
  
  =over
  
  =item *
  
  Initial default values may be specified as part of the option
  specification (using the C<<< default() >>> modifier)
  
  =item *
  
  Default values from the option specification may be modified or replaced
  entirely with default values provided in an external hash
  (such as from a standard config file or environment variables)
  
  =item *
  
  When the command-line array is processed, options and their arguments
  are stored in the order they appeared in the command-line array
  
  =item *
  
  The stored options are applied in-order to modify or replace the set of
  "current" default option values
  
  =item *
  
  If default values are subsequently changed (such as from an alternative
  configuration file), the stored options are re-applied in-order to the
  new set of default option values
  
  =back
  
  With this approach, the resulting option set is always the result of applying
  options (or negations) from the command-line array to a set of default-values.  Users have
  complete freedom to apply whatever precedence rules they wish to the default
  values and may even change default values after the command-line array is
  processed without losing the options given on the command line.
  
  Getopt::Lucid provides several functions to assist in manipulating default
  values:
  
  =over
  
  =item *
  
  C<<< merge_defaults() >>> -- new defaults overwrite any matching, existing defaults.
  KeyPairs hashes and List arrays are replaced entirely with new defaults
  
  =item *
  
  C<<< append_defaults() >>> -- new defaults overwrite any matching, existing defaults,
  except for Counter and List options, which have the new defaults added and
  appended, respectively, and KeyPair options, which are flattened into any
  existing default hash
  
  =item *
  
  C<<< replace_defaults() >>> -- new defaults replace existing defaults; any options
  not provided in the new defaults are reset to zeroE<sol>empty, ignoring any
  default given in the option specification
  
  =item *
  
  C<<< reset_defaults() >>> -- returns defaults to values given in the options
  specification
  
  =back
  
  =head2 Exceptions and Error Handling
  
  Getopt::Lucid uses L<Exception::Class> for exceptions.  When a major error
  occurs, Getopt::Lucid will die and throw one of three Exception::Class
  subclasses:
  
  =over
  
  =item *
  
  C<<< Getopt::Lucid::Exception::Usage >>> -- thrown when Getopt::Lucid methods are
  called incorrectly
  
  =item *
  
  C<<< Getopt::Lucid::Exception::Spec >>> -- thrown when the specification array
  contains incorrect or invalid data
  
  =item *
  
  C<<< Getopt::Lucid::Exception::ARGV >>> -- thrown when the command-line is
  processed and fails to pass specified validation, requirements, or is
  otherwise determined to be invalid
  
  =back
  
  These exception may be caught using an C<<< eval >>> block and allow the calling
  program to respond differently to each class of exception.
  
     my $opt;
     eval { $opt = Getopt::Lucid->getopt( \@spec ) };
     if ($@) {
       print "$@\n" && print_usage() && exit 1
         if ref $@ eq 'Getopt::Lucid::Exception::ARGV';
       ref $@ ? $@->rethrow : die $@;
     }
  
  =head2 Ambiguous Cases and Gotchas
  
  =head3 One-character aliases and C<<< anycase >>>
  
     @spec = (
       Counter("verbose|v")->anycase,
       Switch("version|V")->anycase,
     );
  
  Consider the spec above.  By specifying C<<< anycase >>> on these, "verbose",
  "Verbose", "VERBOSE" are all acceptable, as are "version", "Version" and so on.
  (Including long-form versions of these, too, if "magic" mode is used.)
  However, what if the command line has "-v" or even "-v -V"?  In this case, the
  rule is that exact case matches are used before case-insensitive matches are
  searched.  Thus, "-v" can only match "verbose", despite the C<<< anycase >>>
  modification, and likewise "-V" can only match "version".
  
  =head3 Identical names except for dashes and underscores
  
     @spec = (
       Param("input-file"),
       Switch("input_file"),
     );
  
  Consider the spec above.  These are two, separate, valid options, but a call to
  the accessor C<<< get_input_file >>> is ambiguous and may return either option,
  depending on which first satisfies a "fuzzy-matching" algorithm inside the
  accessor code.  Avoid identical names with mixed dash and underscore styles.
  
  =head1 METHODS
  
  =head2 new()
  
    $opt = Getopt::Lucid->new( \@option_spec );
    $opt = Getopt::Lucid->new( \@option_spec, \%parameters );
    $opt = Getopt::Lucid->new( \@option_spec, \@option_array );
    $opt = Getopt::Lucid->new( \@option_spec, \@option_array, \%parameters );
  
  Creates a new Getopt::Lucid object.  An array reference to an option spec is
  required as an argument.  (See L</USAGE> for a description of the object spec).
  By default, objects will be set to read @ARGV for command line options. An
  optional second argument with a reference to an array will use that array for
  option processing instead.  The final argument may be a hashref of parameters.
  The only valid parameter currently is:
  
  =over
  
  =item *
  
  strict -- enables strict mode when true
  
  =back
  
  For typical cases, users will likely prefer to call C<<< getopt >>> instead, which
  creates a new object and parses the command line with a single function call.
  
  =head2 validate()
  
     $opt->validate();
     $opt->validate( \%arguments );
  
  Takes an optional argument hashref, validates that all requirements and
  prerequisites are met or throws an error.  Valid argument keys are:
  
  =over
  
  =item *
  
  C<<< requires >>> -- an arrayref of options that must exist in the options
  object.
  
  =back
  
  This method returns the object for convenient chaining:
  
     $opt = Getopt::Lucid->getopt(\@spec)->validate;
  
  =head2 append_defaults()
  
    %options = append_defaults( %config_hash );
    %options = append_defaults( \%config_hash );
  
  Takes a hash or hash reference of new default values, modifies the stored
  defaults, recalculates the result of processing the command line with the
  revised defaults, and returns a hash with the resulting options.  Each
  keyE<sol>value pair in the passed hash is added to the stored defaults.  For Switch
  and Param options, the value in the passed hash will overwrite any
  preexisting value.  For Counter options, the value is added to any
  preexisting value.  For List options, the value (or values, if the value is an
  array reference) will be pushed onto the end of the list of existing values.
  For Keypair options, the keyE<sol>value pairs will be added to the existing hash,
  overwriting existing keyE<sol>value pairs (just like merging two hashes).  Keys
  which are not valid names from the options specification will be ignored.
  
  =head2 defaults()
  
    %defaults = $opt->defaults();
  
  Returns a hash containing current default values.  Keys are names from the
  option specification (without any leading dashes).  These defaults represent
  the baseline values that are modified by the parsed command line options.
  
  =head2 getopt()
  
    $opt = Getopt::Lucid->getopt( \@option_spec );
    $opt = Getopt::Lucid->getopt( \@option_spec, \@option_array );
    $opt->getopt();
  
  Parses the command line array (@ARGV by default).  When called as a class
  function, C<<< getopt >>> takes the same arguments as C<<< new >>>, calls C<<< new >>> to create
  an object before parsing the command line, and returns the new object.  When
  called as an object method, it takes no arguments and returns itself.
  
  For convenience, CE<lt>getopts()E<gt> is a alias for CE<lt>getopt()E<gt>.
  
  =head2 merge_defaults()
  
    %options = merge_defaults( %config_hash );
    %options = merge_defaults( \%config_hash );
  
  Takes a hash or hash reference of new default values, modifies the stored
  defaults, recalculates the result of processing the command line with the
  revised defaults, and returns a hash with the resulting options.  Each
  keyE<sol>value pair in the passed hash is added to the stored defaults, overwriting
  any preexisting value.  Keys which are not valid names from the options
  specification will be ignored.
  
  =head2 names()
  
    @names = $opt->names();
  
  Returns the list of names in the options specification.  Each name represents a
  key in the hash of options provided by C<<< options >>>.
  
  =head2 options()
  
    %options = $opt->options();
  
  Returns a deep copy of the options hash.  Before C<<< getopt >>> is called, its
  behavior is undefined.  After C<<< getopt >>> is called, this will return the
  result of modifying the defaults with the results of command line processing.
  
  =head2 replace_defaults()
  
    %options = replace_defaults( %config_hash );
    %options = replace_defaults( \%config_hash );
  
  Takes a hash or hash reference of new default values, replaces the stored
  defaults, recalculates the result of processing the command line with the
  revised defaults, and returns a hash with the resulting options.  Each
  keyE<sol>value pair in the passed hash replaces existing defaults, including those
  given in the option specifications.  Keys which are not valid names from the
  option specification will be ignored.
  
  =head2 reset_defaults()
  
    %options = reset_defaults();
  
  Resets the stored defaults to the original values from the options
  specification, recalculates the result of processing the command line with the
  restored defaults, and returns a hash with the resulting options.  This
  undoes the effect of a C<<< merge_defaults >>> or C<<< add_defaults >>> call.
  
  =head1 API CHANGES
  
  In 1.00, the following API changes have been made:
  
  =over
  
  =item *
  
  C<<< new() >>> now takes an optional hashref of parameters as the last
  argument
  
  =item *
  
  The global C<<< $STRICT >>> variable has been replaced with a per-object
  parameter C<<< strict >>>
  
  =item *
  
  The C<<< required >>> modifier has been removed and a new C<<< validate >>> method
  has been added to facilitate lateE<sol>custom checks of required options
  
  =back
  
  =head1 SEE ALSO
  
  =over
  
  =item *
  
  L<Config::Tiny>
  
  =item *
  
  L<Config::Simple>
  
  =item *
  
  L<Config::Std>
  
  =item *
  
  L<Getopt::Long>
  
  =item *
  
  L<Regexp::Common>
  
  =back
  
  =head1 BUGS
  
  Please report any bugs or feature using the CPAN Request Tracker.
  Bugs can be submitted through the web interface at
  L<http://rt.cpan.org/Dist/Display.html?Queue=Getopt-Lucid>
  
  When submitting a bug or request, please include a test-file or a patch to an
  existing test-file that illustrates the bug or desired feature.
  
  =for :stopwords cpan testmatrix url annocpan anno bugtracker rt cpants kwalitee diff irc mailto metadata placeholders metacpan
  
  =head1 SUPPORT
  
  =head2 Bugs / Feature Requests
  
  Please report any bugs or feature requests through the issue tracker
  at L<https://rt.cpan.org/Public/Dist/Display.html?Name=Getopt-Lucid>.
  You will be notified automatically of any progress on your issue.
  
  =head2 Source Code
  
  This is open source software.  The code repository is available for
  public review and contribution under the terms of the license.
  
  L<https://github.com/dagolden/getopt-lucid>
  
    git clone git://github.com/dagolden/getopt-lucid.git
  
  =head1 AUTHOR
  
  David Golden <dagolden@cpan.org>
  
  =head1 CONTRIBUTORS
  
  =over 4
  
  =item *
  
  Kevin McGrath <kmcgrath@cpan.org>
  
  =item *
  
  Nick Patch <patch@cpan.org>
  
  =item *
  
  Robert Bohne <rbo@cpan.org>
  
  =back
  
  =head1 COPYRIGHT AND LICENSE
  
  This software is Copyright (c) 2013 by David Golden.
  
  This is free software, licensed under:
  
    The Apache License, Version 2.0, January 2004
  
  =cut
GETOPT_LUCID

$fatpacked{"Getopt/Lucid/Exception.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'GETOPT_LUCID_EXCEPTION';
  use 5.006;
  use strict;
  use warnings;
  package Getopt::Lucid::Exception;
  # ABSTRACT: Exception classes for Getopt::Lucid
  our $VERSION = '1.05'; # VERSION
  
  use Exporter;
  our @ISA = qw/Exporter Exception::Class::Base/;
  our @EXPORT = qw( throw_spec throw_argv throw_usage);
  
  use Exception::Class 1.23 (
      "Getopt::Lucid::Exception" => {
          description => "Unidentified exception",
      },
  
      "Getopt::Lucid::Exception::Spec" => {
          description => "Invalid specification",
      },
  
      "Getopt::Lucid::Exception::ARGV" => {
          description => "Invalid argument on command line",
      },
  
      "Getopt::Lucid::Exception::Usage" => {
          description => "Invalid usage",
      },
  
  );
  
  my %throwers = (
      throw_spec => "Getopt::Lucid::Exception::Spec",
      throw_argv => "Getopt::Lucid::Exception::ARGV",
      throw_usage => "Getopt::Lucid::Exception::Usage",
  );
  
  for my $t ( keys %throwers ) {
      no strict 'refs';
      *{$t} = sub { $throwers{$t}->throw("$_[0]\n") };
  }
  
  1;
  
  __END__
  
  =pod
  
  =encoding utf-8
  
  =head1 NAME
  
  Getopt::Lucid::Exception - Exception classes for Getopt::Lucid
  
  =head1 VERSION
  
  version 1.05
  
  =for Pod::Coverage description
  throw_argv
  throw_spec
  throw_usage
  
  =head1 AUTHOR
  
  David Golden <dagolden@cpan.org>
  
  =head1 CONTRIBUTORS
  
  =over 4
  
  =item *
  
  Kevin McGrath <kmcgrath@cpan.org>
  
  =item *
  
  Nick Patch <patch@cpan.org>
  
  =item *
  
  Robert Bohne <rbo@cpan.org>
  
  =back
  
  =head1 COPYRIGHT AND LICENSE
  
  This software is Copyright (c) 2013 by David Golden.
  
  This is free software, licensed under:
  
    The Apache License, Version 2.0, January 2004
  
  =cut
GETOPT_LUCID_EXCEPTION

$fatpacked{"Modern/Perl.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'MODERN_PERL';
  package Modern::Perl;
  # ABSTRACT: enable all of the features of Modern Perl with one import
  $Modern::Perl::VERSION = '1.20150127';
  use 5.010_000;
  
  use strict;
  use warnings;
  
  use mro     ();
  use feature ();
  
  # enable methods on filehandles; unnecessary when 5.14 autoloads them
  use IO::File   ();
  use IO::Handle ();
  
  our $VERSION;
  
  my $wanted_date;
  sub VERSION
  {
      my ($self, $version) = @_;
  
      return $VERSION unless defined $version;
      return $VERSION if             $version < 2009;
  
      $wanted_date = $version if (caller(1))[3] =~ /::BEGIN/;
      return 2014;
  }
  
  sub import
  {
      my ($class, $date) = @_;
      $date = $wanted_date unless defined $date;
  
      my $feature_tag    = validate_date( $date );
      undef $wanted_date;
  
      warnings->import;
      strict->import;
      feature->import( $feature_tag );
      mro::set_mro( scalar caller(), 'c3' );
  }
  
  sub unimport
  {
      warnings->unimport;
      strict->unimport;
      feature->unimport;
  }
  
  my %dates =
  (
      2009 => ':5.10',
      2010 => ':5.10',
      2011 => ':5.12',
      2012 => ':5.14',
      2013 => ':5.16',
      2014 => ':5.18',
      2015 => ':5.20',
  );
  
  sub validate_date
  {
      my $date = shift;
  
      # always enable unicode_strings when available
      unless ($date)
      {
          return ':5.12' if $] > 5.011003;
          return ':5.10';
      }
  
      my $year = substr $date, 0, 4;
      return $dates{$year} if exists $dates{$year};
  
      die "Unknown date '$date' requested\n";
  }
  
  
  1;
  
  __END__
  
  =pod
  
  =encoding UTF-8
  
  =head1 NAME
  
  Modern::Perl - enable all of the features of Modern Perl with one import
  
  =head1 VERSION
  
  version 1.20150127
  
  =head1 SYNOPSIS
  
  Modern Perl programs use several modules to enable additional features of Perl
  and of the CPAN.  Instead of copying and pasting all of these C<use> lines,
  instead write only one:
  
      use Modern::Perl;
  
  This enables the L<strict> and L<warnings> pragmas, as well as all of the
  features available in Perl 5.10. It also enables C3 method resolution order as
  documented in C<perldoc mro> and loads L<IO::File> and L<IO::Handle> so that
  you may call methods on filehandles. In the future, it may include additional
  core modules and pragmas.
  
  Because so much of this module's behavior uses lexically scoped pragmas, you
  may disable these pragmas within an inner scope with:
  
      no Modern::Perl;
  
  See L<http://www.modernperlbooks.com/mt/2009/01/toward-a-modernperl.html> for
  more information, L<http://www.modernperlbooks.com/> for further discussion of
  Modern Perl and its implications, and
  L<http://onyxneon.com/books/modern_perl/index.html> for a freely-downloadable
  Modern Perl tutorial.
  
  =head2 Forward Compatibility
  
  For forward compatibility, I recommend you specify a I<year> as the single
  optional import tag. For example:
  
      use Modern::Perl '2009';
      use Modern::Perl '2010';
  
  ... both enable 5.10 features, while:
  
      use Modern::Perl '2011';
  
  ... enables 5.12 features:
  
      use Modern::Perl '2012';
  
  ... enables 5.14 features:
  
      use Modern::Perl '2013';
  
  ... enables 5.16 features, and:
  
      use Modern::Perl '2014';
  
  ... enables 5.18 features, and:
  
      use Modern::Perl '2015';
  
  ... enables 5.20 features.
  
  Obviously you cannot use newer features on earlier
  versions. Perl will throw the appropriate exception if you try.
  
  By mid-2014, this module will drop support for 5.10 and 5.12 and will complain
  (once per process) if you use a year too old. As of January 2014, Perl 5.14 is
  unsupported by the Perl 5 Porters, so please consider upgrading.
  
  =head1 AUTHOR
  
  chromatic, C<< <chromatic at wgz.org> >>
  
  =head1 BUGS
  
  None reported.
  
  Please report any bugs or feature requests to C<bug-modern-perl at
  rt.cpan.org>, or through the web interface at
  L<http://rt.cpan.org/NoAuth/ReportBug.html?Queue=Modern-Perl>.  I will be
  notified, and then you'll automatically be notified of progress on your bug as
  I make changes.
  
  =head1 SUPPORT
  
  You can find documentation for this module with the perldoc command.
  
      perldoc Modern::Perl
  
  You can also look for information at:
  
  =over 4
  
  =item * RT: CPAN's request tracker
  
  L<http://rt.cpan.org/NoAuth/Bugs.html?Dist=Modern-Perl>
  
  =item * AnnoCPAN: Annotated CPAN documentation
  
  L<http://annocpan.org/dist/Modern-Perl>
  
  =item * CPAN Ratings
  
  L<http://cpanratings.perl.org/d/Modern-Perl>
  
  =item * Search CPAN
  
  L<http://search.cpan.org/dist/Modern-Perl/>
  
  =back
  
  =head1 ACKNOWLEDGEMENTS
  
  Damian Conway (inspiration from L<Toolkit>), Florian Ragwitz
  (L<B::Hooks::Parser>, so I didn't have to write it myself), chocolateboy (for
  suggesting that I don't even need L<B::Hooks::Parser>), Damien Learns Perl,
  David Moreno, Evan Carroll, Elliot Shank, Andreas König, Father Chrysostomos,
  and Norbert E. Grüner for reporting bugs, filing patches, and requesting
  features.
  
  =head1 COPYRIGHT & LICENSE
  
  Copyright 2009-2014 chromatic, all rights reserved.
  
  This program is free software; you can redistribute it and/or modify it
  under the same terms as Perl 5.18 itself.
  
  =head1 AUTHOR
  
  chromatic
  
  =head1 COPYRIGHT AND LICENSE
  
  This software is copyright (c) 2015 by chromatic@wgz.org.
  
  This is free software; you can redistribute it and/or modify it under
  the same terms as the Perl 5 programming language system itself.
  
  =cut
MODERN_PERL

$fatpacked{"Parallel/ForkManager.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'PARALLEL_FORKMANAGER';
  =head1 NAME
  
  Parallel::ForkManager - A simple parallel processing fork manager
  
  =head1 SYNOPSIS
  
    use Parallel::ForkManager;
  
    my $pm = Parallel::ForkManager->new($MAX_PROCESSES);
  
    DATA_LOOP:
    foreach my $data (@all_data) {
      # Forks and returns the pid for the child:
      my $pid = $pm->start and next DATA_LOOP;
  
      ... do some work with $data in the child process ...
  
      $pm->finish; # Terminates the child process
    }
  
  =head1 DESCRIPTION
  
  This module is intended for use in operations that can be done in parallel
  where the number of processes to be forked off should be limited. Typical
  use is a downloader which will be retrieving hundreds/thousands of files.
  
  The code for a downloader would look something like this:
  
    use LWP::Simple;
    use Parallel::ForkManager;
  
    ...
  
    my @links=(
      ["http://www.foo.bar/rulez.data","rulez_data.txt"],
      ["http://new.host/more_data.doc","more_data.doc"],
      ...
    );
  
    ...
  
    # Max 30 processes for parallel download
    my $pm = Parallel::ForkManager->new(30);
  
    LINKS:
    foreach my $linkarray (@links) {
      $pm->start and next LINKS; # do the fork
  
      my ($link, $fn) = @$linkarray;
      warn "Cannot get $fn from $link"
        if getstore($link, $fn) != RC_OK;
  
      $pm->finish; # do the exit in the child process
    }
    $pm->wait_all_children;
  
  First you need to instantiate the ForkManager with the "new" constructor.
  You must specify the maximum number of processes to be created. If you
  specify 0, then NO fork will be done; this is good for debugging purposes.
  
  Next, use $pm->start to do the fork. $pm returns 0 for the child process,
  and child pid for the parent process (see also L<perlfunc(1p)/fork()>).
  The "and next" skips the internal loop in the parent process. NOTE:
  $pm->start dies if the fork fails.
  
  $pm->finish terminates the child process (assuming a fork was done in the
  "start").
  
  NOTE: You cannot use $pm->start if you are already in the child process.
  If you want to manage another set of subprocesses in the child process,
  you must instantiate another Parallel::ForkManager object!
  
  =head1 METHODS
  
  The comment letter indicates where the method should be run. P for parent,
  C for child.
  
  =over 5
  
  =item new $processes
  
  Instantiate a new Parallel::ForkManager object. You must specify the maximum
  number of children to fork off. If you specify 0 (zero), then no children
  will be forked. This is intended for debugging purposes.
  
  The optional second parameter, $tempdir, is only used if you want the
  children to send back a reference to some data (see RETRIEVING DATASTRUCTURES
  below). If not provided, it is set via a call to L<File::Temp>::tempdir().
  
  The new method will die if the temporary directory does not exist or it is not
  a directory.
  
  =item start [ $process_identifier ]
  
  This method does the fork. It returns the pid of the child process for
  the parent, and 0 for the child process. If the $processes parameter
  for the constructor is 0 then, assuming you're in the child process,
  $pm->start simply returns 0.
  
  An optional $process_identifier can be provided to this method... It is used by
  the "run_on_finish" callback (see CALLBACKS) for identifying the finished
  process.
  
  =item finish [ $exit_code [, $data_structure_reference] ]
  
  Closes the child process by exiting and accepts an optional exit code
  (default exit code is 0) which can be retrieved in the parent via callback.
  If the second optional parameter is provided, the child attempts to send
  it's contents back to the parent. If you use the program in debug mode
  ($processes == 0), this method just calls the callback.
  
  If the $data_structure_reference is provided, then it is serialized and
  passed to the parent process. See RETRIEVING DATASTRUCTURES for more info.
  
  =item set_max_procs $processes
  
  Allows you to set a new maximum number of children to maintain.
  
  =item wait_all_children
  
  You can call this method to wait for all the processes which have been
  forked. This is a blocking wait.
  
  =item reap_finished_children
  
  This is a non-blocking call to reap children and execute callbacks independent
  of calls to "start" or "wait_all_children". Use this in scenarios where "start"
  is called infrequently but you would like the callbacks executed quickly.
  
  =item is_parent
  
  Returns C<true> if within the parent or C<false> if within the child.
  
  =item is_child
  
  Returns C<true> if within the child or C<false> if within the parent.
  
  =item max_procs 
  
  Returns the maximal number of processes the object will fork.
  
  =item running_procs
  
  Returns the pids of the forked processes currently monitored by the
  C<Parallel::ForkManager>. Note that children are still reported as running
  until the fork manager harvest them, via the next call to
  C<start> or C<wait_all_children>.
  
      my @pids = $pm->running_procs;
  
      my $nbr_children =- $pm->running_procs;
  
  =item wait_for_available_procs( $n )
  
  Wait until C<$n> available process slots are available.
  If C<$n> is not given, defaults to I<1>.
  
  =item waitpid_blocking_sleep 
  
  Returns the sleep period, in seconds, of the pseudo-blocking calls. The sleep
  period can be a fraction of second. 
  
  Returns C<0> if disabled. 
  
  Defaults to 1 second.
  
  See I<BLOCKING CALLS> for more details.
  
  =item set_waitpid_blocking_sleep $seconds
  
  Sets the the sleep period, in seconds, of the pseudo-blocking calls.
  Set to C<0> to disable.
  
  See I<BLOCKING CALLS> for more details.
  
  =back
  
  =head1 CALLBACKS
  
  You can define callbacks in the code, which are called on events like starting
  a process or upon finish. Declare these before the first call to start().
  
  The callbacks can be defined with the following methods:
  
  =over 4
  
  =item run_on_finish $code [, $pid ]
  
  You can define a subroutine which is called when a child is terminated. It is
  called in the parent process.
  
  The parameters of the $code are the following:
  
    - pid of the process, which is terminated
    - exit code of the program
    - identification of the process (if provided in the "start" method)
    - exit signal (0-127: signal name)
    - core dump (1 if there was core dump at exit)
    - datastructure reference or undef (see RETRIEVING DATASTRUCTURES)
  
  =item run_on_start $code
  
  You can define a subroutine which is called when a child is started. It called
  after the successful startup of a child in the parent process.
  
  The parameters of the $code are the following:
  
    - pid of the process which has been started
    - identification of the process (if provided in the "start" method)
  
  =item run_on_wait $code, [$period]
  
  You can define a subroutine which is called when the child process needs to wait
  for the startup. If $period is not defined, then one call is done per
  child. If $period is defined, then $code is called periodically and the
  module waits for $period seconds between the two calls. Note, $period can be
  fractional number also. The exact "$period seconds" is not guaranteed,
  signals can shorten and the process scheduler can make it longer (on busy
  systems).
  
  The $code called in the "start" and the "wait_all_children" method also.
  
  No parameters are passed to the $code on the call.
  
  =back
  
  =head1 BLOCKING CALLS
  
  When it comes to waiting for child processes to terminate, C<Parallel::ForkManager> is between 
  a fork and a hard place (if you excuse the terrible pun). The underlying Perl C<waitpid> function
  that the module relies on can block until either one specific or any child process 
  terminate, but not for a process part of a given group.
  
  This means that the module can do one of two things when it waits for 
  one of its child processes to terminate:
  
  =over
  
  =item Only wait for its own child processes
  
  This is done via a loop using a C<waitpid> non-blocking call and a sleep statement.
  The code does something along the lines of
  
      while(1) {
          if ( any of the P::FM child process terminated ) {
              return its pid
          }
  
          sleep $sleep_period
      }
  
  This is the default behavior that the module will use.
  This is not the most efficient way to wait for child processes, but it's
  the safest way to ensure that C<Parallel::ForkManager> won't interfere with 
  any other part of the codebase. 
  
  The sleep period is set via the method C<set_waitpid_blocking_sleep>.
  
  =item Block until any process terminate
  
  Alternatively, C<Parallel::ForkManager> can call C<waitpid> such that it will
  block until any child process terminate. If the child process was not one of
  the monitored subprocesses, the wait will resume. This is more efficient, but mean
  that C<P::FM> can captures (and discards) the termination notification that a different
  part of the code might be waiting for. 
  
  If this is a race condition
  that doesn't apply to your codebase, you can set the 
  I<waitpid_blocking_sleep> period to C<0>, which will enable C<waitpid> call blocking.
  
      my $pm = Parallel::ForkManager->new( 4 );
  
      $pm->set_waitpid_blocking_sleep(0);  # true blocking calls enabled
  
      for ( 1..100 ) {
          $pm->start and next;
  
          ...; # do work
  
          $pm->finish;
      }
  
  =back
  
  =head1 RETRIEVING DATASTRUCTURES from child processes
  
  The ability for the parent to retrieve data structures is new as of version
  0.7.6.
  
  Each child process may optionally send 1 data structure back to the parent.
  By data structure, we mean a reference to a string, hash or array. The
  contents of the data structure are written out to temporary files on disc
  using the L<Storable> modules' store() method. The reference is then
  retrieved from within the code you send to the run_on_finish callback.
  
  The data structure can be any scalar perl data structure which makes sense:
  string, numeric value or a reference to an array, hash or object.
  
  There are 2 steps involved in retrieving data structures:
  
  1) A reference to the data structure the child wishes to send back to the
  parent is provided as the second argument to the finish() call. It is up
  to the child to decide whether or not to send anything back to the parent.
  
  2) The data structure reference is retrieved using the callback provided in
  the run_on_finish() method.
  
  Keep in mind that data structure retrieval is not the same as returning a
  data structure from a method call. That is not what actually occurs. The
  data structure referenced in a given child process is serialized and
  written out to a file by L<Storable>. The file is subsequently read back
  into memory and a new data structure belonging to the parent process is
  created. Please consider the performance penality it can imply, so try to
  keep the returned structure small.
  
  =head1 EXAMPLES
  
  =head2 Parallel get
  
  This small example can be used to get URLs in parallel.
  
    use Parallel::ForkManager;
    use LWP::Simple;
  
    my $pm = Parallel::ForkManager->new(10);
  
    LINKS:
    for my $link (@ARGV) {
      $pm->start and next LINKS;
      my ($fn) = $link =~ /^.*\/(.*?)$/;
      if (!$fn) {
        warn "Cannot determine filename from $fn\n";
      } else {
        $0 .= " " . $fn;
        print "Getting $fn from $link\n";
        my $rc = getstore($link, $fn);
        print "$link downloaded. response code: $rc\n";
      };
      $pm->finish;
    };
  
  =head2 Callbacks
  
  Example of a program using callbacks to get child exit codes:
  
    use strict;
    use Parallel::ForkManager;
  
    my $max_procs = 5;
    my @names = qw( Fred Jim Lily Steve Jessica Bob Dave Christine Rico Sara );
    # hash to resolve PID's back to child specific information
  
    my $pm = Parallel::ForkManager->new($max_procs);
  
    # Setup a callback for when a child finishes up so we can
    # get it's exit code
    $pm->run_on_finish( sub {
        my ($pid, $exit_code, $ident) = @_;
        print "** $ident just got out of the pool ".
          "with PID $pid and exit code: $exit_code\n";
    });
  
    $pm->run_on_start( sub {
        my ($pid, $ident)=@_;
        print "** $ident started, pid: $pid\n";
    });
  
    $pm->run_on_wait( sub {
        print "** Have to wait for one children ...\n"
      },
      0.5
    );
  
    NAMES:
    foreach my $child ( 0 .. $#names ) {
      my $pid = $pm->start($names[$child]) and next NAMES;
  
      # This code is the child process
      print "This is $names[$child], Child number $child\n";
      sleep ( 2 * $child );
      print "$names[$child], Child $child is about to get out...\n";
      sleep 1;
      $pm->finish($child); # pass an exit code to finish
    }
  
    print "Waiting for Children...\n";
    $pm->wait_all_children;
    print "Everybody is out of the pool!\n";
  
  =head2 Data structure retrieval
  
  In this simple example, each child sends back a string reference.
  
    use Parallel::ForkManager 0.7.6;
    use strict;
  
    my $pm = Parallel::ForkManager->new(2, '/server/path/to/temp/dir/');
  
    # data structure retrieval and handling
    $pm -> run_on_finish ( # called BEFORE the first call to start()
      sub {
        my ($pid, $exit_code, $ident, $exit_signal, $core_dump, $data_structure_reference) = @_;
  
        # retrieve data structure from child
        if (defined($data_structure_reference)) {  # children are not forced to send anything
          my $string = ${$data_structure_reference};  # child passed a string reference
          print "$string\n";
        }
        else {  # problems occuring during storage or retrieval will throw a warning
          print qq|No message received from child process $pid!\n|;
        }
      }
    );
  
    # prep random statement components
    my @foods = ('chocolate', 'ice cream', 'peanut butter', 'pickles', 'pizza', 'bacon', 'pancakes', 'spaghetti', 'cookies');
    my @preferences = ('loves', q|can't stand|, 'always wants more', 'will walk 100 miles for', 'only eats', 'would starve rather than eat');
  
    # run the parallel processes
    PERSONS:
    foreach my $person (qw(Fred Wilma Ernie Bert Lucy Ethel Curly Moe Larry)) {
      $pm->start() and next PERSONS;
  
      # generate a random statement about food preferences
      my $statement = $person . ' ' . $preferences[int(rand @preferences)] . ' ' . $foods[int(rand @foods)];
  
      # send it back to the parent process
      $pm->finish(0, \$statement);  # note that it's a scalar REFERENCE, not the scalar itself
    }
    $pm->wait_all_children;
  
  A second datastructure retrieval example demonstrates how children decide
  whether or not to send anything back, what to send and how the parent should
  process whatever is retrieved.
  
  =for example begin
  
    use Parallel::ForkManager 0.7.6;
    use Data::Dumper;  # to display the data structures retrieved.
    use strict;
  
    my $pm = Parallel::ForkManager->new(20);  # using the system temp dir $L<File::Temp::tempdir()
  
    # data structure retrieval and handling
    my %retrieved_responses = ();  # for collecting responses
    $pm -> run_on_finish (
      sub {
        my ($pid, $exit_code, $ident, $exit_signal, $core_dump, $data_structure_reference) = @_;
  
        # see what the child sent us, if anything
        if (defined($data_structure_reference)) {  # test rather than assume child sent anything
          my $reftype = ref($data_structure_reference);
          print qq|ident "$ident" returned a "$reftype" reference.\n\n|;
          if (1) {  # simple on/off switch to display the contents
            print &Dumper($data_structure_reference) . qq|end of "$ident" sent structure\n\n|;
          }
  
          # we can also collect retrieved data structures for processing after all children have exited
          $retrieved_responses{$ident} = $data_structure_reference;
        } else {
          print qq|ident "$ident" did not send anything.\n\n|;
        }
      }
    );
  
    # generate a list of instructions
    my @instructions = (  # a unique identifier and what the child process should send
      {'name' => '%ENV keys as a string', 'send' => 'keys'},
      {'name' => 'Send Nothing'},  # not instructing the child to send anything back to the parent
      {'name' => 'Childs %ENV', 'send' => 'all'},
      {'name' => 'Child chooses randomly', 'send' => 'random'},
      {'name' => 'Invalid send instructions', 'send' => 'Na Na Nana Na'},
      {'name' => 'ENV values in an array', 'send' => 'values'},
    );
  
    INSTRUCTS:
    foreach my $instruction (@instructions) {
      $pm->start($instruction->{'name'}) and next INSTRUCTS;  # this time we are using an explicit, unique child process identifier
  
      # last step in child processing
      $pm->finish(0) unless $instruction->{'send'};  # no data structure is sent unless this child is told what to send.
  
      if ($instruction->{'send'} eq 'keys') {
        $pm->finish(0, \join(', ', keys %ENV));
  
      } elsif ($instruction->{'send'} eq 'values') {
        $pm->finish(0, [values %ENV]);  # kinda useless without knowing which keys they belong to...
  
      } elsif ($instruction->{'send'} eq 'all') {
        $pm->finish(0, \%ENV);  # remember, we are not "returning" anything, just copying the hash to disc
  
      # demonstrate clearly that the child determines what type of reference to send
      } elsif ($instruction->{'send'} eq 'random') {
        my $string = q|I'm just a string.|;
        my @array = qw(I am an array);
        my %hash = (type => 'associative array', synonym => 'hash', cool => 'very :)');
        my $return_choice = ('string', 'array', 'hash')[int(rand 3)];  # randomly choose return data type
        $pm->finish(0, \$string) if ($return_choice eq 'string');
        $pm->finish(0, \@array) if ($return_choice eq 'array');
        $pm->finish(0, \%hash) if ($return_choice eq 'hash');
  
      # as a responsible child, inform parent that their instruction was invalid
      } else {
        $pm->finish(0, \qq|Invalid instructions: "$instruction->{'send'}".|);  # ordinarily I wouldn't include invalid input in a response...
      }
    }
    $pm->wait_all_children;  # blocks until all forked processes have exited
  
    # post fork processing of returned data structures
    for (sort keys %retrieved_responses) {
      print qq|Post processing "$_"...\n|;
    }
  
  =for example end
  
  =head1 BUGS AND LIMITATIONS
  
  Do not use Parallel::ForkManager in an environment, where other child
  processes can affect the run of the main program, so using this module
  is not recommended in an environment where fork() / wait() is already used.
  
  If you want to use more than one copies of the Parallel::ForkManager, then
  you have to make sure that all children processes are terminated, before you
  use the second object in the main program.
  
  You are free to use a new copy of Parallel::ForkManager in the child
  processes, although I don't think it makes sense.
  
  =head1 COPYRIGHT
  
  =encoding utf8
  
  Copyright (c) 2000-2010 Szabó, Balázs (dLux)
  
  All right reserved. This program is free software; you can redistribute it
  and/or modify it under the same terms as Perl itself.
  
  =head1 AUTHOR
  
    dLux (Szabó, Balázs) <dlux@dlux.hu>
  
  =head1 CREDITS
  
    Gábor Szabó (szabgab@cpan.org)  (co-maintainer)
    Michael Gang (bug report)
    Noah Robin <sitz@onastick.net> (documentation tweaks)
    Chuck Hirstius <chirstius@megapathdsl.net> (callback exit status, example)
    Grant Hopwood <hopwoodg@valero.com> (win32 port)
    Mark Southern <mark_southern@merck.com> (bugfix)
    Ken Clarke <www.perlprogrammer.net>  (datastructure retrieval)
  
  =cut
  
  package Parallel::ForkManager;
  use POSIX ":sys_wait_h";
  use Storable qw(store retrieve);
  use File::Spec;
  use File::Temp ();
  use File::Path ();
  use Carp;
  
  use strict;
  use vars qw($VERSION);
  $VERSION="1.15";
  $VERSION = eval $VERSION;
  
  sub new {
    my ($c,$processes,$tempdir)=@_;
  
    my $h={
      max_proc   => $processes,
      processes  => {},
      in_child   => 0,
      parent_pid => $$,
      auto_cleanup => ($tempdir ? 0 : 1),
      waitpid_blocking_sleep => 1,
    };
  
  
    # determine temporary directory for storing data structures
    # add it to Parallel::ForkManager object so children can use it
    # We don't let it clean up so it won't do it in the child process
    # but we have our own DESTROY to do that.
    if (not defined($tempdir) or not length($tempdir)) {
      $tempdir = File::Temp::tempdir(CLEANUP => 0);
    }
    die qq|Temporary directory "$tempdir" doesn't exist or is not a directory.| unless (-e $tempdir && -d _);  # ensure temp dir exists and is indeed a directory
    $h->{tempdir} = $tempdir;
  
    return bless($h,ref($c)||$c);
  };
  
  sub start {
    my ($s,$identification)=@_;
  
    die "Cannot start another process while you are in the child process"
      if $s->{in_child};
    while ($s->{max_proc} && ( keys %{ $s->{processes} } ) >= $s->{max_proc}) {
      $s->on_wait;
      $s->wait_one_child(defined $s->{on_wait_period} ? &WNOHANG : undef);
    };
    $s->wait_children;
    if ($s->{max_proc}) {
      my $pid=fork();
      die "Cannot fork: $!" if !defined $pid;
      if ($pid) {
        $s->{processes}->{$pid}=$identification;
        $s->on_start($pid,$identification);
      } else {
        $s->{in_child}=1 if !$pid;
      }
      return $pid;
    } else {
      $s->{processes}->{$$}=$identification;
      $s->on_start($$,$identification);
      return 0; # Simulating the child which returns 0
    }
  }
  
  sub finish {
    my ($s, $x, $r)=@_;
  
    if ( $s->{in_child} ) {
      if (defined($r)) {  # store the child's data structure
        my $storable_tempfile = File::Spec->catfile($s->{tempdir}, 'Parallel-ForkManager-' . $s->{parent_pid} . '-' . $$ . '.txt');
        my $stored = eval { return &store($r, $storable_tempfile); };
  
        # handle Storables errors, IE logcarp or carp returning undef, or die (via logcroak or croak)
        if (not $stored or $@) {
          warn(qq|The storable module was unable to store the child's data structure to the temp file "$storable_tempfile":  | . join(', ', $@));
        }
      }
      CORE::exit($x || 0);
    }
    if ($s->{max_proc} == 0) { # max_proc == 0
      $s->on_finish($$, $x ,$s->{processes}->{$$}, 0, 0, $r);
      delete $s->{processes}->{$$};
    }
    return 0;
  }
  
  sub wait_children {
    my ($s)=@_;
  
    return if !keys %{$s->{processes}};
    my $kid;
    do {
      $kid = $s->wait_one_child(&WNOHANG);
    } while $kid > 0 || $kid < -1; # AS 5.6/Win32 returns negative PIDs
  };
  
  *wait_childs=*wait_children; # compatibility
  *reap_finished_children=*wait_children; # behavioral synonym for clarity
  
  sub wait_one_child {
    my ($s,$par)=@_;
  
    my $kid;
    while (1) {
      $kid = $s->_waitpid(-1,$par||=0);
      last if $kid == 0 || $kid == -1; # AS 5.6/Win32 returns negative PIDs
      redo if !exists $s->{processes}->{$kid};
      my $id = delete $s->{processes}->{$kid};
  
      # retrieve child data structure, if any
      my $retrieved = undef;
      my $storable_tempfile = File::Spec->catfile($s->{tempdir}, 'Parallel-ForkManager-' . $$ . '-' . $kid . '.txt');
      if (-e $storable_tempfile) {  # child has option of not storing anything, so we need to see if it did or not
        $retrieved = eval { return &retrieve($storable_tempfile); };
  
        # handle Storables errors
        if (not $retrieved or $@) {
          warn(qq|The storable module was unable to retrieve the child's data structure from the temporary file "$storable_tempfile":  | . join(', ', $@));
        }
  
        # clean up after ourselves
        unlink $storable_tempfile;
      }
  
      $s->on_finish( $kid, $? >> 8 , $id, $? & 0x7f, $? & 0x80 ? 1 : 0, $retrieved);
      last;
    }
    $kid;
  };
  
  sub wait_all_children {
    my ($s)=@_;
  
    while (keys %{ $s->{processes} }) {
      $s->on_wait;
      $s->wait_one_child(defined $s->{on_wait_period} ? &WNOHANG : undef);
    };
  }
  
  *wait_all_childs=*wait_all_children; # compatibility;
  
  sub max_procs { $_[0]->{max_proc}; }
  
  sub is_child  { $_[0]->{in_child} }
  
  sub is_parent { !$_[0]->{in_child} }
  
  sub running_procs {
      my $self = shift;
  
      my @pids = keys %{ $self->{processes} };
      return @pids;
  }
  
  sub wait_for_available_procs {
      my( $self, $nbr ) = @_;
      $nbr ||= 1;
  
      croak "nbr processes '$nbr' higher than the max nbr of processes (@{[ $self->max_procs ]})"
          if $nbr > $self->max_procs;
  
      $self->wait_one_child until $self->max_procs - $self->running_procs >= $nbr;
  }
  
  sub run_on_finish {
    my ($s,$code,$pid)=@_;
  
    $s->{on_finish}->{$pid || 0}=$code;
  }
  
  sub on_finish {
    my ($s,$pid,@par)=@_;
  
    my $code=$s->{on_finish}->{$pid} || $s->{on_finish}->{0} or return 0;
    $code->($pid,@par);
  };
  
  sub run_on_wait {
    my ($s,$code, $period)=@_;
  
    $s->{on_wait}=$code;
    $s->{on_wait_period} = $period;
  }
  
  sub on_wait {
    my ($s)=@_;
  
    if(ref($s->{on_wait}) eq 'CODE') {
      $s->{on_wait}->();
      if (defined $s->{on_wait_period}) {
          local $SIG{CHLD} = sub { } if ! defined $SIG{CHLD};
          select undef, undef, undef, $s->{on_wait_period}
      };
    };
  };
  
  sub run_on_start {
    my ($s,$code)=@_;
  
    $s->{on_start}=$code;
  }
  
  sub on_start {
    my ($s,@par)=@_;
  
    $s->{on_start}->(@par) if ref($s->{on_start}) eq 'CODE';
  };
  
  sub set_max_procs {
    my ($s, $mp)=@_;
  
    $s->{max_proc} = $mp;
  }
  
  sub set_waitpid_blocking_sleep {
      my( $self, $period ) = @_;
      $self->{waitpid_blocking_sleep} = $period;
  }
  
  sub waitpid_blocking_sleep {
      $_[0]->{waitpid_blocking_sleep};
  }
  
  sub _waitpid { # Call waitpid() in the standard Unix fashion.
      my( $self, $pid, $flag ) = @_;
  
      return $flag ? $self->_waitpid_non_blocking : $self->_waitpid_blocking;
  }
  
  sub _waitpid_non_blocking {
      my $self = shift;
  
      for my $pid ( $self->running_procs ) {
          my $p = waitpid $pid, &WNOHANG or next;
  
          return $pid if $p != -1;
  
          warn "child process '$pid' disappeared. A call to `waitpid` outside of Parallel::ForkManager might have reaped it.\n";
          # it's gone. let's clean the process entry
          delete $self->{processes}{$pid};
      }
  
      return -1;
  }
  
  sub _waitpid_blocking {
      my $self = shift;
  
      # pseudo-blocking
      if( my $sleep_period = $self->{waitpid_blocking_sleep} ) {
          while() {
              my $pid = $self->_waitpid_non_blocking;
              return $pid if $pid;
  
              select undef, undef, undef, $sleep_period;
          }
      }
  
      return waitpid -1, 0;
  }
  
  sub DESTROY {
    my ($self) = @_;
  
    if ($self->{auto_cleanup} && $self->{parent_pid} == $$ && -d $self->{tempdir}) {
      File::Path::remove_tree($self->{tempdir});
    }
  }
  
  1;
PARALLEL_FORKMANAGER

$fatpacked{"autodie.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'AUTODIE';
  package autodie;
  use 5.008;
  use strict;
  use warnings;
  
  use parent qw(Fatal);
  our $VERSION;
  
  # ABSTRACT: Replace functions with ones that succeed or die with lexical scope
  
  BEGIN {
      our $VERSION = '2.26'; # VERSION: Generated by DZP::OurPkg::Version
  }
  
  use constant ERROR_WRONG_FATAL => q{
  Incorrect version of Fatal.pm loaded by autodie.
  
  The autodie pragma uses an updated version of Fatal to do its
  heavy lifting.  We seem to have loaded Fatal version %s, which is
  probably the version that came with your version of Perl.  However
  autodie needs version %s, which would have come bundled with
  autodie.
  
  You may be able to solve this problem by adding the following
  line of code to your main program, before any use of Fatal or
  autodie.
  
      use lib "%s";
  
  };
  
  # We have to check we've got the right version of Fatal before we
  # try to compile the rest of our code, lest we use a constant
  # that doesn't exist.
  
  BEGIN {
  
      # If we have the wrong Fatal, then we've probably loaded the system
      # one, not our own.  Complain, and give a useful hint. ;)
  
      if (defined($Fatal::VERSION) and defined($VERSION) and $Fatal::VERSION ne $VERSION) {
          my $autodie_path = $INC{'autodie.pm'};
  
          $autodie_path =~ s/autodie\.pm//;
  
          require Carp;
  
          Carp::croak sprintf(
              ERROR_WRONG_FATAL, $Fatal::VERSION, $VERSION, $autodie_path
          );
      }
  }
  
  # When passing args to Fatal we want to keep the first arg
  # (our package) in place.  Hence the splice.
  
  sub import {
          splice(@_,1,0,Fatal::LEXICAL_TAG);
          goto &Fatal::import;
  }
  
  sub unimport {
          splice(@_,1,0,Fatal::LEXICAL_TAG);
          goto &Fatal::unimport;
  }
  
  1;
  
  __END__
  
  =head1 NAME
  
  autodie - Replace functions with ones that succeed or die with lexical scope
  
  =head1 SYNOPSIS
  
      use autodie;            # Recommended: implies 'use autodie qw(:default)'
  
      use autodie qw(:all);   # Recommended more: defaults and system/exec.
  
      use autodie qw(open close);   # open/close succeed or die
  
      open(my $fh, "<", $filename); # No need to check!
  
      {
          no autodie qw(open);          # open failures won't die
          open(my $fh, "<", $filename); # Could fail silently!
          no autodie;                   # disable all autodies
      }
      
      print "Hello World" or die $!;    # autodie DOESN'T check print!
  
  =head1 DESCRIPTION
  
          bIlujDI' yIchegh()Qo'; yIHegh()!
  
          It is better to die() than to return() in failure.
  
                  -- Klingon programming proverb.
  
  The C<autodie> pragma provides a convenient way to replace functions
  that normally return false on failure with equivalents that throw
  an exception on failure.
  
  The C<autodie> pragma has I<lexical scope>, meaning that functions
  and subroutines altered with C<autodie> will only change their behaviour
  until the end of the enclosing block, file, or C<eval>.
  
  If C<system> is specified as an argument to C<autodie>, then it
  uses L<IPC::System::Simple> to do the heavy lifting.  See the
  description of that module for more information.
  
  =head1 EXCEPTIONS
  
  Exceptions produced by the C<autodie> pragma are members of the
  L<autodie::exception> class.  The preferred way to work with
  these exceptions under Perl 5.10 is as follows:
  
      use feature qw(switch);
  
      eval {
          use autodie;
  
          open(my $fh, '<', $some_file);
  
          my @records = <$fh>;
  
          # Do things with @records...
  
          close($fh);
  
      };
  
      given ($@) {
          when (undef)   { say "No error";                    }
          when ('open')  { say "Error from open";             }
          when (':io')   { say "Non-open, IO error.";         }
          when (':all')  { say "All other autodie errors."    }
          default        { say "Not an autodie error at all." }
      }
  
  Under Perl 5.8, the C<given/when> structure is not available, so the
  following structure may be used:
  
      eval {
          use autodie;
  
          open(my $fh, '<', $some_file);
  
          my @records = <$fh>;
  
          # Do things with @records...
  
          close($fh);
      };
  
      if ($@ and $@->isa('autodie::exception')) {
          if ($@->matches('open')) { print "Error from open\n";   }
          if ($@->matches(':io' )) { print "Non-open, IO error."; }
      } elsif ($@) {
          # A non-autodie exception.
      }
  
  See L<autodie::exception> for further information on interrogating
  exceptions.
  
  =head1 CATEGORIES
  
  Autodie uses a simple set of categories to group together similar
  built-ins.  Requesting a category type (starting with a colon) will
  enable autodie for all built-ins beneath that category.  For example,
  requesting C<:file> will enable autodie for C<close>, C<fcntl>,
  C<open> and C<sysopen>.
  
  The categories are currently:
  
      :all
          :default
              :io
                  read
                  seek
                  sysread
                  sysseek
                  syswrite
                  :dbm
                      dbmclose
                      dbmopen
                  :file
                      binmode
                      close
                      chmod
                      chown
                      fcntl
                      flock
                      ioctl
                      open
                      sysopen
                      truncate
                  :filesys
                      chdir
                      closedir
                      opendir
                      link
                      mkdir
                      readlink
                      rename
                      rmdir
                      symlink
                      unlink
                  :ipc
                      kill
                      pipe
                      :msg
                          msgctl
                          msgget
                          msgrcv
                          msgsnd
                      :semaphore
                          semctl
                          semget
                          semop
                      :shm
                          shmctl
                          shmget
                          shmread
                  :socket
                      accept
                      bind
                      connect
                      getsockopt
                      listen
                      recv
                      send
                      setsockopt
                      shutdown
                      socketpair
              :threads
                  fork
          :system
              system
              exec
  
  
  Note that while the above category system is presently a strict
  hierarchy, this should not be assumed.
  
  A plain C<use autodie> implies C<use autodie qw(:default)>.  Note that
  C<system> and C<exec> are not enabled by default.  C<system> requires
  the optional L<IPC::System::Simple> module to be installed, and enabling
  C<system> or C<exec> will invalidate their exotic forms.  See L</BUGS>
  below for more details.
  
  The syntax:
  
      use autodie qw(:1.994);
  
  allows the C<:default> list from a particular version to be used.  This
  provides the convenience of using the default methods, but the surety
  that no behavioral changes will occur if the C<autodie> module is
  upgraded.
  
  C<autodie> can be enabled for all of Perl's built-ins, including
  C<system> and C<exec> with:
  
      use autodie qw(:all);
  
  =head1 FUNCTION SPECIFIC NOTES
  
  =head2 print
  
  The autodie pragma B<<does not check calls to C<print>>>.
  
  =head2 flock
  
  It is not considered an error for C<flock> to return false if it fails
  due to an C<EWOULDBLOCK> (or equivalent) condition.  This means one can
  still use the common convention of testing the return value of
  C<flock> when called with the C<LOCK_NB> option:
  
      use autodie;
  
      if ( flock($fh, LOCK_EX | LOCK_NB) ) {
          # We have a lock
      }
  
  Autodying C<flock> will generate an exception if C<flock> returns
  false with any other error.
  
  =head2 system/exec
  
  The C<system> built-in is considered to have failed in the following
  circumstances:
  
  =over 4
  
  =item *
  
  The command does not start.
  
  =item *
  
  The command is killed by a signal.
  
  =item *
  
  The command returns a non-zero exit value (but see below).
  
  =back
  
  On success, the autodying form of C<system> returns the I<exit value>
  rather than the contents of C<$?>.
  
  Additional allowable exit values can be supplied as an optional first
  argument to autodying C<system>:
  
      system( [ 0, 1, 2 ], $cmd, @args);  # 0,1,2 are good exit values
  
  C<autodie> uses the L<IPC::System::Simple> module to change C<system>.
  See its documentation for further information.
  
  Applying C<autodie> to C<system> or C<exec> causes the exotic
  forms C<system { $cmd } @args > or C<exec { $cmd } @args>
  to be considered a syntax error until the end of the lexical scope.
  If you really need to use the exotic form, you can call C<CORE::system>
  or C<CORE::exec> instead, or use C<no autodie qw(system exec)> before
  calling the exotic form.
  
  =head1 GOTCHAS
  
  Functions called in list context are assumed to have failed if they
  return an empty list, or a list consisting only of a single undef
  element.
  
  Some builtins (e.g. C<chdir> or C<truncate>) has a call signature that
  cannot completely be representated with a Perl prototype.  This means
  that some valid Perl code will be invalid under autodie.  As an example:
  
    chdir(BAREWORD);
  
  Without autodie (and assuming BAREWORD is an open
  filehandle/dirhandle) this is a valid call to chdir.  But under
  autodie, C<chdir> will behave like it had the prototype ";$" and thus
  BAREWORD will be a syntax error (under "use strict".  Without strict, it
  will interpreted as a filename).
  
  =head1 DIAGNOSTICS
  
  =over 4
  
  =item :void cannot be used with lexical scope
  
  The C<:void> option is supported in L<Fatal>, but not
  C<autodie>.  To workaround this, C<autodie> may be explicitly disabled until
  the end of the current block with C<no autodie>.
  To disable autodie for only a single function (eg, open)
  use C<no autodie qw(open)>.
  
  C<autodie> performs no checking of called context to determine whether to throw
  an exception; the explicitness of error handling with C<autodie> is a deliberate
  feature.
  
  =item No user hints defined for %s
  
  You've insisted on hints for user-subroutines, either by pre-pending
  a C<!> to the subroutine name itself, or earlier in the list of arguments
  to C<autodie>.  However the subroutine in question does not have
  any hints available.
  
  =back
  
  See also L<Fatal/DIAGNOSTICS>.
  
  =head1 BUGS
  
  "Used only once" warnings can be generated when C<autodie> or C<Fatal>
  is used with package filehandles (eg, C<FILE>).  Scalar filehandles are
  strongly recommended instead.
  
  When using C<autodie> or C<Fatal> with user subroutines, the
  declaration of those subroutines must appear before the first use of
  C<Fatal> or C<autodie>, or have been exported from a module.
  Attempting to use C<Fatal> or C<autodie> on other user subroutines will
  result in a compile-time error.
  
  Due to a bug in Perl, C<autodie> may "lose" any format which has the
  same name as an autodying built-in or function.
  
  C<autodie> may not work correctly if used inside a file with a
  name that looks like a string eval, such as F<eval (3)>.
  
  =head2 autodie and string eval
  
  Due to the current implementation of C<autodie>, unexpected results
  may be seen when used near or with the string version of eval.
  I<None of these bugs exist when using block eval>.
  
  Under Perl 5.8 only, C<autodie> I<does not> propagate into string C<eval>
  statements, although it can be explicitly enabled inside a string
  C<eval>.
  
  Under Perl 5.10 only, using a string eval when C<autodie> is in
  effect can cause the autodie behaviour to leak into the surrounding
  scope.  This can be worked around by using a C<no autodie> at the
  end of the scope to explicitly remove autodie's effects, or by
  avoiding the use of string eval.
  
  I<None of these bugs exist when using block eval>.  The use of
  C<autodie> with block eval is considered good practice.
  
  =head2 REPORTING BUGS
  
  Please report bugs via the GitHub Issue Tracker at
  L<https://github.com/pjf/autodie/issues> or via the CPAN Request
  Tracker at L<https://rt.cpan.org/NoAuth/Bugs.html?Dist=autodie>.
  
  =head1 FEEDBACK
  
  If you find this module useful, please consider rating it on the
  CPAN Ratings service at
  L<http://cpanratings.perl.org/rate?distribution=autodie> .
  
  The module author loves to hear how C<autodie> has made your life
  better (or worse).  Feedback can be sent to
  E<lt>pjf@perltraining.com.auE<gt>.
  
  =head1 AUTHOR
  
  Copyright 2008-2009, Paul Fenwick E<lt>pjf@perltraining.com.auE<gt>
  
  =head1 LICENSE
  
  This module is free software.  You may distribute it under the
  same terms as Perl itself.
  
  =head1 SEE ALSO
  
  L<Fatal>, L<autodie::exception>, L<autodie::hints>, L<IPC::System::Simple>
  
  I<Perl tips, autodie> at
  L<http://perltraining.com.au/tips/2008-08-20.html>
  
  =head1 ACKNOWLEDGEMENTS
  
  Mark Reed and Roland Giersig -- Klingon translators.
  
  See the F<AUTHORS> file for full credits.  The latest version of this
  file can be found at
  L<https://github.com/pjf/autodie/tree/master/AUTHORS> .
  
  =cut
AUTODIE

$fatpacked{"autodie/Scope/Guard.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'AUTODIE_SCOPE_GUARD';
  package autodie::Scope::Guard;
  
  use strict;
  use warnings;
  
  # ABSTRACT: Wrapper class for calling subs at end of scope
  our $VERSION = '2.26'; # VERSION
  
  # This code schedules the cleanup of subroutines at the end of
  # scope.  It's directly inspired by chocolateboy's excellent
  # Scope::Guard module.
  
  sub new {
      my ($class, $handler) = @_;
      return bless($handler, $class);
  }
  
  sub DESTROY {
      my ($self) = @_;
  
      $self->();
  }
  
  1;
  
  __END__
  
  =head1 NAME
  
  autodie::Scope::Guard - Wrapper class for calling subs at end of scope
  
  =head1 SYNOPSIS
  
      use autodie::Scope::Guard;
      $^H{'my-key'} = autodie::Scope::Guard->new(sub {
          print "Hallo world\n";
      });
  
  =head1 DESCRIPTION
  
  This class is used to bless perl subs so that they are invoked when
  they are destroyed.  This is mostly useful for ensuring the code is
  invoked at end of scope.  This module is not a part of autodie's
  public API.
  
  This module is directly inspired by chocolateboy's excellent
  Scope::Guard module.
  
  =head2 Methods
  
  =head3 new
  
    my $hook = autodie::Scope::Guard->new(sub {});
  
  Creates a new C<autodie::Scope::Guard>, which will invoke the given
  sub once it goes out of scope (i.e. its DESTROY handler is called).
  
  =head1 AUTHOR
  
  Copyright 2008-2009, Paul Fenwick E<lt>pjf@perltraining.com.auE<gt>
  
  =head1 LICENSE
  
  This module is free software.  You may distribute it under the
  same terms as Perl itself.
AUTODIE_SCOPE_GUARD

$fatpacked{"autodie/Scope/GuardStack.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'AUTODIE_SCOPE_GUARDSTACK';
  package autodie::Scope::GuardStack;
  
  use strict;
  use warnings;
  
  use autodie::Scope::Guard;
  
  # ABSTRACT: Hook stack for managing scopes via %^H
  our $VERSION = '2.26'; # VERSION
  
  my $H_KEY_STEM = __PACKAGE__ . '/guard';
  my $COUNTER = 0;
  
  # This code schedules the cleanup of subroutines at the end of
  # scope.  It's directly inspired by chocolateboy's excellent
  # Scope::Guard module.
  
  sub new {
      my ($class) = @_;
  
      return bless([], $class);
  }
  
  sub push_hook {
      my ($self, $hook) = @_;
      my $h_key = $H_KEY_STEM . ($COUNTER++);
      my $size = @{$self};
      $^H{$h_key} = autodie::Scope::Guard->new(sub {
          # Pop the stack until we reach the right size
          # - this may seem weird, but it is to avoid relying
          #   on "destruction order" of keys in %^H.
          #
          # Example:
          #  {
          #     use autodie;  # hook 1
          #     no autodie;   # hook 2
          #     use autodie;  # hook 3
          #  }
          #
          #  Here we want call hook 3, then hook 2 and finally hook 1.
          #  Any other order could have undesired consequences.
          #
          #  Suppose hook 2 is destroyed first, it will pop hook 3 and
          #  then hook 2.  hook 3 will then be destroyed, but do nothing
          #  since its "frame" was already popped and finally hook 1
          #  will be popped and take its own frame with it.
          #
          #  We need to check that $self still exists since things can get weird
          #  during global destruction.
          $self->_pop_hook while $self && @{$self} > $size;
      });
      push(@{$self}, [$hook, $h_key]);
      return;
  }
  
  sub _pop_hook {
      my ($self) = @_;
      my ($hook, $key) = @{ pop(@{$self}) };
      my $ref = delete($^H{$key});
      $hook->();
      return;
  }
  
  sub DESTROY {
      my ($self) = @_;
  
      # To be honest, I suspect @{$self} will always be empty here due
      # to the subs in %^H having references to the stack (which would
      # keep the stack alive until those have been destroyed).  Anyhow,
      # it never hurt to be careful.
      $self->_pop_hook while @{$self};
      return;
  }
  
  1;
  
  __END__
  
  =head1 NAME
  
  autodie::Scope::GuardStack -  Hook stack for managing scopes via %^H
  
  =head1 SYNOPSIS
  
      use autodie::Scope::GuardStack;
      my $stack = autodie::Scope::GuardStack->new
      $^H{'my-key'} = $stack;
  
      $stack->push_hook(sub {});
  
  =head1 DESCRIPTION
  
  This class is a stack of hooks to be called in the right order as
  scopes go away.  The stack is only useful when inserted into C<%^H>
  and will pop hooks as their "scope" is popped.  This is useful for
  uninstalling or reinstalling subs in a namespace as a pragma goes
  out of scope.
  
  Due to how C<%^H> works, this class is only useful during the
  compilation phase of a perl module and relies on the internals of how
  perl handles references in C<%^H>.  This module is not a part of
  autodie's public API.
  
  =head2 Methods
  
  =head3 new
  
    my $stack = autodie::Scope::GuardStack->new;
  
  Creates a new C<autodie::Scope::GuardStack>.  The stack is initially
  empty and must be inserted into C<%^H> by the creator.
  
  =head3 push_hook
  
    $stack->push_hook(sub {});
  
  Add a sub to the stack.  The sub will be called once the current
  compile-time "scope" is left.  Multiple hooks can be added per scope
  
  =head1 AUTHOR
  
  Copyright 2013, Niels Thykier E<lt>niels@thykier.netE<gt>
  
  =head1 LICENSE
  
  This module is free software.  You may distribute it under the
  same terms as Perl itself.
AUTODIE_SCOPE_GUARDSTACK

$fatpacked{"autodie/ScopeUtil.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'AUTODIE_SCOPEUTIL';
  package autodie::ScopeUtil;
  
  use strict;
  use warnings;
  
  # Docs say that perl 5.8.3 has Exporter 5.57 and autodie requires
  # 5.8.4, so this should "just work".
  use Exporter 5.57 qw(import);
  
  use autodie::Scope::GuardStack;
  
  our @EXPORT_OK = qw(on_end_of_compile_scope);
  
  # ABSTRACT: Utilities for managing %^H scopes
  our $VERSION = '2.26'; # VERSION
  
  # docs says we should pick __PACKAGE__ /<whatever>
  my $H_STACK_KEY = __PACKAGE__ . '/stack';
  
  sub on_end_of_compile_scope {
      my ($hook) = @_;
  
      # Dark magic to have autodie work under 5.8
      # Copied from namespace::clean, that copied it from
      # autobox, that found it on an ancient scroll written
      # in blood.
  
      # This magic bit causes %^H to be lexically scoped.
      $^H |= 0x020000;
  
      my $stack = $^H{$H_STACK_KEY};
      if (not defined($stack)) {
          $stack = autodie::Scope::GuardStack->new;
          $^H{$H_STACK_KEY} = $stack;
      }
  
      $stack->push_hook($hook);
      return;
  }
  
  1;
  
  =head1 NAME
  
  autodie::ScopeUtil - Utilities for managing %^H scopes
  
  =head1 SYNOPSIS
  
      use autodie::ScopeUtil qw(on_end_of_compile_scope);
      on_end_of_compile_scope(sub { print "Hallo world\n"; });
  
  =head1 DESCRIPTION
  
  Utilities for abstracting away the underlying magic of (ab)using
  C<%^H> to call subs at the end of a (compile-time) scopes.
  
  Due to how C<%^H> works, these utilities are only useful during the
  compilation phase of a perl module and relies on the internals of how
  perl handles references in C<%^H>.  This module is not a part of
  autodie's public API.
  
  =head2 Methods
  
  =head3 on_end_of_compile_scope
  
    on_end_of_compile_scope(sub { print "Hallo world\n"; });
  
  Will invoke a sub at the end of a (compile-time) scope.  The sub is
  called once with no arguments.  Can be called multiple times (even in
  the same "compile-time" scope) to install multiple subs.  Subs are
  called in a "first-in-last-out"-order (FILO or "stack"-order).
  
  =head1 AUTHOR
  
  Copyright 2013, Niels Thykier E<lt>niels@thykier.netE<gt>
  
  =head1 LICENSE
  
  This module is free software.  You may distribute it under the
  same terms as Perl itself.
AUTODIE_SCOPEUTIL

$fatpacked{"autodie/exception.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'AUTODIE_EXCEPTION';
  package autodie::exception;
  use 5.008;
  use strict;
  use warnings;
  use Carp qw(croak);
  
  our $VERSION = '2.26'; # VERSION: Generated by DZP::OurPkg:Version
  # ABSTRACT: Exceptions from autodying functions.
  
  our $DEBUG = 0;
  
  use overload
      q{""} => "stringify",
      # Overload smart-match only if we're using 5.10 or up
      ($] >= 5.010 ? ('~~'  => "matches") : ()),
      fallback => 1
  ;
  
  my $PACKAGE = __PACKAGE__;  # Useful to have a scalar for hash keys.
  
  =head1 NAME
  
  autodie::exception - Exceptions from autodying functions.
  
  =head1 SYNOPSIS
  
      eval {
          use autodie;
  
          open(my $fh, '<', 'some_file.txt');
  
          ...
      };
  
      if (my $E = $@) {
          say "Ooops!  ",$E->caller," had problems: $@";
      }
  
  
  =head1 DESCRIPTION
  
  When an L<autodie> enabled function fails, it generates an
  C<autodie::exception> object.  This can be interrogated to
  determine further information about the error that occurred.
  
  This document is broken into two sections; those methods that
  are most useful to the end-developer, and those methods for
  anyone wishing to subclass or get very familiar with
  C<autodie::exception>.
  
  =head2 Common Methods
  
  These methods are intended to be used in the everyday dealing
  of exceptions.
  
  The following assume that the error has been copied into
  a separate scalar:
  
      if ($E = $@) {
          ...
      }
  
  This is not required, but is recommended in case any code
  is called which may reset or alter C<$@>.
  
  =cut
  
  =head3 args
  
      my $array_ref = $E->args;
  
  Provides a reference to the arguments passed to the subroutine
  that died.
  
  =cut
  
  sub args        { return $_[0]->{$PACKAGE}{args}; }
  
  =head3 function
  
      my $sub = $E->function;
  
  The subroutine (including package) that threw the exception.
  
  =cut
  
  sub function   { return $_[0]->{$PACKAGE}{function};  }
  
  =head3 file
  
      my $file = $E->file;
  
  The file in which the error occurred (eg, C<myscript.pl> or
  C<MyTest.pm>).
  
  =cut
  
  sub file        { return $_[0]->{$PACKAGE}{file};  }
  
  =head3 package
  
      my $package = $E->package;
  
  The package from which the exceptional subroutine was called.
  
  =cut
  
  sub package     { return $_[0]->{$PACKAGE}{package}; }
  
  =head3 caller
  
      my $caller = $E->caller;
  
  The subroutine that I<called> the exceptional code.
  
  =cut
  
  sub caller      { return $_[0]->{$PACKAGE}{caller};  }
  
  =head3 line
  
      my $line = $E->line;
  
  The line in C<< $E->file >> where the exceptional code was called.
  
  =cut
  
  sub line        { return $_[0]->{$PACKAGE}{line};  }
  
  =head3 context
  
      my $context = $E->context;
  
  The context in which the subroutine was called by autodie; usually
  the same as the context in which you called the autodying subroutine.
  This can be 'list', 'scalar', or undefined (unknown).  It will never
  be 'void', as C<autodie> always captures the return value in one way
  or another.
  
  For some core functions that always return a scalar value regardless
  of their context (eg, C<chown>), this may be 'scalar', even if you
  used a list context.
  
  =cut
  
  # TODO: The comments above say this can be undefined. Is that actually
  # the case? (With 'system', perhaps?)
  
  sub context     { return $_[0]->{$PACKAGE}{context} }
  
  =head3 return
  
      my $return_value = $E->return;
  
  The value(s) returned by the failed subroutine.  When the subroutine
  was called in a list context, this will always be a reference to an
  array containing the results.  When the subroutine was called in
  a scalar context, this will be the actual scalar returned.
  
  =cut
  
  sub return      { return $_[0]->{$PACKAGE}{return} }
  
  =head3 errno
  
      my $errno = $E->errno;
  
  The value of C<$!> at the time when the exception occurred.
  
  B<NOTE>: This method will leave the main C<autodie::exception> class
  and become part of a role in the future.  You should only call
  C<errno> for exceptions where C<$!> would reasonably have been
  set on failure.
  
  =cut
  
  # TODO: Make errno part of a role.  It doesn't make sense for
  # everything.
  
  sub errno       { return $_[0]->{$PACKAGE}{errno}; }
  
  =head3 eval_error
  
      my $old_eval_error = $E->eval_error;
  
  The contents of C<$@> immediately after autodie triggered an
  exception.  This may be useful when dealing with modules such
  as L<Text::Balanced> that set (but do not throw) C<$@> on error.
  
  =cut
  
  sub eval_error { return $_[0]->{$PACKAGE}{eval_error}; }
  
  =head3 matches
  
      if ( $e->matches('open') ) { ... }
  
      if ( $e ~~ 'open' ) { ... }
  
  C<matches> is used to determine whether a
  given exception matches a particular role.  On Perl 5.10,
  using smart-match (C<~~>) with an C<autodie::exception> object
  will use C<matches> underneath.
  
  An exception is considered to match a string if:
  
  =over 4
  
  =item *
  
  For a string not starting with a colon, the string exactly matches the
  package and subroutine that threw the exception.  For example,
  C<MyModule::log>.  If the string does not contain a package name,
  C<CORE::> is assumed.
  
  =item *
  
  For a string that does start with a colon, if the subroutine
  throwing the exception I<does> that behaviour.  For example, the
  C<CORE::open> subroutine does C<:file>, C<:io> and C<:all>.
  
  See L<autodie/CATEGORIES> for further information.
  
  =back
  
  =cut
  
  {
      my (%cache);
  
      sub matches {
          my ($this, $that) = @_;
  
          # TODO - Handle references
          croak "UNIMPLEMENTED" if ref $that;
  
          my $sub = $this->function;
  
          if ($DEBUG) {
              my $sub2 = $this->function;
              warn "Smart-matching $that against $sub / $sub2\n";
          }
  
          # Direct subname match.
          return 1 if $that eq $sub;
          return 1 if $that !~ /:/ and "CORE::$that" eq $sub;
          return 0 if $that !~ /^:/;
  
          # Cached match / check tags.
          require Fatal;
  
          if (exists $cache{$sub}{$that}) {
              return $cache{$sub}{$that};
          }
  
          # This rather awful looking line checks to see if our sub is in the
          # list of expanded tags, caches it, and returns the result.
  
          return $cache{$sub}{$that} = grep { $_ eq $sub } @{ $this->_expand_tag($that) };
      }
  }
  
  # This exists primarily so that child classes can override or
  # augment it if they wish.
  
  sub _expand_tag {
      my ($this, @args) = @_;
  
      return Fatal->_expand_tag(@args);
  }
  
  =head2 Advanced methods
  
  The following methods, while usable from anywhere, are primarily
  intended for developers wishing to subclass C<autodie::exception>,
  write code that registers custom error messages, or otherwise
  work closely with the C<autodie::exception> model.
  
  =cut
  
  # The table below records customer formatters.
  # TODO - Should this be a package var instead?
  # TODO - Should these be in a completely different file, or
  #        perhaps loaded on demand?  Most formatters will never
  #        get used in most programs.
  
  my %formatter_of = (
      'CORE::close'    => \&_format_close,
      'CORE::open'     => \&_format_open,
      'CORE::dbmopen'  => \&_format_dbmopen,
      'CORE::flock'    => \&_format_flock,
      'CORE::read'     => \&_format_readwrite,
      'CORE::sysread'  => \&_format_readwrite,
      'CORE::syswrite' => \&_format_readwrite,
  );
  
  # TODO: Our tests only check LOCK_EX | LOCK_NB is properly
  # formatted.  Try other combinations and ensure they work
  # correctly.
  
  sub _format_flock {
      my ($this) = @_;
  
      require Fcntl;
  
      my $filehandle = $this->args->[0];
      my $raw_mode   = $this->args->[1];
  
      my $mode_type;
      my $lock_unlock;
  
      if ($raw_mode & Fcntl::LOCK_EX() ) {
          $lock_unlock = "lock";
          $mode_type = "for exclusive access";
      }
      elsif ($raw_mode & Fcntl::LOCK_SH() ) {
          $lock_unlock = "lock";
          $mode_type = "for shared access";
      }
      elsif ($raw_mode & Fcntl::LOCK_UN() ) {
          $lock_unlock = "unlock";
          $mode_type = "";
      }
      else {
          # I've got no idea what they're trying to do.
          $lock_unlock = "lock";
          $mode_type = "with mode $raw_mode";
      }
  
      my $cooked_filehandle;
  
      if ($filehandle and not ref $filehandle) {
  
          # A package filehandle with a name!
  
          $cooked_filehandle = " $filehandle";
      }
      else {
          # Otherwise we have a scalar filehandle.
  
          $cooked_filehandle = '';
  
      }
  
      local $! = $this->errno;
  
      return "Can't $lock_unlock filehandle$cooked_filehandle $mode_type: $!";
  
  }
  
  # Default formatter for CORE::dbmopen
  sub _format_dbmopen {
      my ($this) = @_;
      my @args   = @{$this->args};
  
      # TODO: Presently, $args flattens out the (usually empty) hash
      # which is passed as the first argument to dbmopen.  This is
      # a bug in our args handling code (taking a reference to it would
      # be better), but for the moment we'll just examine the end of
      # our arguments list for message formatting.
  
      my $mode = $args[-1];
      my $file = $args[-2];
  
      # If we have a mask, then display it in octal, not decimal.
      # We don't do this if it already looks octalish, or doesn't
      # look like a number.
  
      if ($mode =~ /^[^\D0]\d+$/) {
          $mode = sprintf("0%lo", $mode);
      };
  
      local $! = $this->errno;
  
      return "Can't dbmopen(%hash, '$file', $mode): '$!'";
  }
  
  # Default formatter for CORE::close
  
  sub _format_close {
      my ($this) = @_;
      my $close_arg = $this->args->[0];
  
      local $! = $this->errno;
  
      # If we've got an old-style filehandle, mention it.
      if ($close_arg and not ref $close_arg) {
          return "Can't close filehandle '$close_arg': '$!'";
      }
  
      # TODO - This will probably produce an ugly error.  Test and fix.
      return "Can't close($close_arg) filehandle: '$!'";
  
  }
  
  # Default formatter for CORE::read, CORE::sysread and CORE::syswrite
  #
  # Similar to default formatter with the buffer filtered out as it
  # may contain binary data.
  sub _format_readwrite {
      my ($this) = @_;
      my $call = $this->function;
      local $! = $this->errno;
  
      # Trim package name off dying sub for error messages.
      $call =~ s/.*:://;
  
      # These subs receive the following arguments (in order):
      #
      # * FILEHANDLE
      # * SCALAR (buffer, we do not want to write this)
      # * LENGTH (optional for syswrite)
      # * OFFSET (optional for all)
      my (@args) = @{$this->args};
      my $arg_name = $args[1];
      if (defined($arg_name)) {
          if (ref($arg_name)) {
              my $name = blessed($arg_name) || ref($arg_name);
              $arg_name = "<${name}>";
          } else {
              $arg_name = '<BUFFER>';
          }
      } else {
          $arg_name = '<UNDEF>';
      }
      $args[1] = $arg_name;
  
      return "Can't $call(" . join(q{, }, @args) . "): $!";
  }
  
  # Default formatter for CORE::open
  
  use constant _FORMAT_OPEN => "Can't open '%s' for %s: '%s'";
  
  sub _format_open_with_mode {
      my ($this, $mode, $file, $error) = @_;
  
      my $wordy_mode;
  
      if    ($mode eq '<')  { $wordy_mode = 'reading';   }
      elsif ($mode eq '>')  { $wordy_mode = 'writing';   }
      elsif ($mode eq '>>') { $wordy_mode = 'appending'; }
  
      $file = '<undef>' if not defined $file;
  
      return sprintf _FORMAT_OPEN, $file, $wordy_mode, $error if $wordy_mode;
  
      Carp::confess("Internal autodie::exception error: Don't know how to format mode '$mode'.");
  
  }
  
  sub _format_open {
      my ($this) = @_;
  
      my @open_args = @{$this->args};
  
      # Use the default formatter for single-arg and many-arg open
      if (@open_args <= 1 or @open_args >= 4) {
          return $this->format_default;
      }
  
      # For two arg open, we have to extract the mode
      if (@open_args == 2) {
          my ($fh, $file) = @open_args;
  
          if (ref($fh) eq "GLOB") {
              $fh = '$fh';
          }
  
          my ($mode) = $file =~ m{
              ^\s*                # Spaces before mode
              (
                  (?>             # Non-backtracking subexp.
                      <           # Reading
                      |>>?        # Writing/appending
                  )
              )
              [^&]                # Not an ampersand (which means a dup)
          }x;
  
          if (not $mode) {
              # Maybe it's a 2-arg open without any mode at all?
              # Detect the most simple case for this, where our
              # file consists only of word characters.
  
              if ( $file =~ m{^\s*\w+\s*$} ) {
                  $mode = '<'
              }
              else {
                  # Otherwise, we've got no idea what's going on.
                  # Use the default.
                  return $this->format_default;
              }
          }
  
          # Localising $! means perl makes it a pretty error for us.
          local $! = $this->errno;
  
          return $this->_format_open_with_mode($mode, $file, $!);
      }
  
      # Here we must be using three arg open.
  
      my $file = $open_args[2];
  
      local $! = $this->errno;
  
      my $mode = $open_args[1];
  
      local $@;
  
      my $msg = eval { $this->_format_open_with_mode($mode, $file, $!); };
  
      return $msg if $msg;
  
      # Default message (for pipes and odd things)
  
      return "Can't open '$file' with mode '$open_args[1]': '$!'";
  }
  
  =head3 register
  
      autodie::exception->register( 'CORE::open' => \&mysub );
  
  The C<register> method allows for the registration of a message
  handler for a given subroutine.  The full subroutine name including
  the package should be used.
  
  Registered message handlers will receive the C<autodie::exception>
  object as the first parameter.
  
  =cut
  
  sub register {
      my ($class, $symbol, $handler) = @_;
  
      croak "Incorrect call to autodie::register" if @_ != 3;
  
      $formatter_of{$symbol} = $handler;
  
  }
  
  =head3 add_file_and_line
  
      say "Problem occurred",$@->add_file_and_line;
  
  Returns the string C< at %s line %d>, where C<%s> is replaced with
  the filename, and C<%d> is replaced with the line number.
  
  Primarily intended for use by format handlers.
  
  =cut
  
  # Simply produces the file and line number; intended to be added
  # to the end of error messages.
  
  sub add_file_and_line {
      my ($this) = @_;
  
      return sprintf(" at %s line %d\n", $this->file, $this->line);
  }
  
  =head3 stringify
  
      say "The error was: ",$@->stringify;
  
  Formats the error as a human readable string.  Usually there's no
  reason to call this directly, as it is used automatically if an
  C<autodie::exception> object is ever used as a string.
  
  Child classes can override this method to change how they're
  stringified.
  
  =cut
  
  sub stringify {
      my ($this) = @_;
  
      my $call        =  $this->function;
      my $msg;
  
      if ($DEBUG) {
          my $dying_pkg   = $this->package;
          my $sub   = $this->function;
          my $caller = $this->caller;
          warn "Stringifing exception for $dying_pkg :: $sub / $caller / $call\n";
      }
  
      # TODO - This isn't using inheritance.  Should it?
      if ( my $sub = $formatter_of{$call} ) {
          $msg = $sub->($this) . $this->add_file_and_line;
      } else {
          $msg = $this->format_default . $this->add_file_and_line;
      }
      $msg .=  $this->{$PACKAGE}{_stack_trace}
          if $Carp::Verbose;
  
      return $msg;
  }
  
  =head3 format_default
  
      my $error_string = $E->format_default;
  
  This produces the default error string for the given exception,
  I<without using any registered message handlers>.  It is primarily
  intended to be called from a message handler when they have
  been passed an exception they don't want to format.
  
  Child classes can override this method to change how default
  messages are formatted.
  
  =cut
  
  # TODO: This produces ugly errors.  Is there any way we can
  # dig around to find the actual variable names?  I know perl 5.10
  # does some dark and terrible magicks to find them for undef warnings.
  
  sub format_default {
      my ($this) = @_;
  
      my $call        =  $this->function;
  
      local $! = $this->errno;
  
      # TODO: This is probably a good idea for CORE, is it
      # a good idea for other subs?
  
      # Trim package name off dying sub for error messages.
      $call =~ s/.*:://;
  
      # Walk through all our arguments, and...
      #
      #   * Replace undef with the word 'undef'
      #   * Replace globs with the string '$fh'
      #   * Quote all other args.
  
      my @args = @{ $this->args() };
  
      foreach my $arg (@args) {
         if    (not defined($arg))   { $arg = 'undef' }
         elsif (ref($arg) eq "GLOB") { $arg = '$fh'   }
         else                        { $arg = qq{'$arg'} }
      }
  
      # Format our beautiful error.
  
      return "Can't $call(".  join(q{, }, @args) . "): $!" ;
  
      # TODO - Handle user-defined errors from hash.
  
      # TODO - Handle default error messages.
  
  }
  
  =head3 new
  
      my $error = autodie::exception->new(
          args => \@_,
          function => "CORE::open",
          errno => $!,
          context => 'scalar',
          return => undef,
      );
  
  
  Creates a new C<autodie::exception> object.  Normally called
  directly from an autodying function.  The C<function> argument
  is required, its the function we were trying to call that
  generated the exception.  The C<args> parameter is optional.
  
  The C<errno> value is optional.  In versions of C<autodie::exception>
  1.99 and earlier the code would try to automatically use the
  current value of C<$!>, but this was unreliable and is no longer
  supported.
  
  Atrributes such as package, file, and caller are determined
  automatically, and cannot be specified.
  
  =cut
  
  sub new {
      my ($class, @args) = @_;
  
      my $this = {};
  
      bless($this,$class);
  
      # I'd love to use EVERY here, but it causes our code to die
      # because it wants to stringify our objects before they're
      # initialised, causing everything to explode.
  
      $this->_init(@args);
  
      return $this;
  }
  
  sub _init {
  
      my ($this, %args) = @_;
  
      # Capturing errno here is not necessarily reliable.
      my $original_errno = $!;
  
      our $init_called = 1;
  
      my $class = ref $this;
  
      # We're going to walk up our call stack, looking for the
      # first thing that doesn't look like our exception
      # code, autodie/Fatal, or some whacky eval.
  
      my ($package, $file, $line, $sub);
  
      my $depth = 0;
  
      while (1) {
          $depth++;
  
          ($package, $file, $line, $sub) = CORE::caller($depth);
  
          # Skip up the call stack until we find something outside
          # of the Fatal/autodie/eval space.
  
          next if $package->isa('Fatal');
          next if $package->isa($class);
          next if $package->isa(__PACKAGE__);
  
          # Anything with the 'autodie::skip' role wants us to skip it.
          # https://github.com/pjf/autodie/issues/15
  
          next if ($package->can('DOES') and $package->DOES('autodie::skip'));
  
          next if $file =~ /^\(eval\s\d+\)$/;
  
          last;
  
      }
  
      # We now have everything correct, *except* for our subroutine
      # name.  If it's __ANON__ or (eval), then we need to keep on
      # digging deeper into our stack to find the real name.  However we
      # don't update our other information, since that will be correct
      # for our current exception.
  
      my $first_guess_subroutine = $sub;
  
      while (defined $sub and $sub =~ /^\(eval\)$|::__ANON__$/) {
          $depth++;
  
          $sub = (CORE::caller($depth))[3];
      }
  
      # If we end up falling out the bottom of our stack, then our
      # __ANON__ guess is the best we can get.  This includes situations
      # where we were called from the top level of a program.
  
      if (not defined $sub) {
          $sub = $first_guess_subroutine;
      }
  
      $this->{$PACKAGE}{package} = $package;
      $this->{$PACKAGE}{file}    = $file;
      $this->{$PACKAGE}{line}    = $line;
      $this->{$PACKAGE}{caller}  = $sub;
  
      # Tranks to %Carp::CarpInternal all Fatal, autodie and
      # autodie::exception stack frames are filtered already, but our
      # nameless wrapper is still present, so strip that.
  
      my $trace = Carp::longmess();
      $trace =~ s/^\s*at \(eval[^\n]+\n//;
  
      # And if we see an __ANON__, then we'll replace that with the actual
      # name of our autodying function.
  
      my $short_func = $args{function};
      $short_func =~ s/^CORE:://;
      $trace =~ s/(\s*[\w:]+)__ANON__/$1$short_func/;
  
      # And now we just fill in all our attributes.
  
      $this->{$PACKAGE}{_stack_trace} = $trace;
  
      $this->{$PACKAGE}{errno}   = $args{errno} || 0;
  
      $this->{$PACKAGE}{context} = $args{context};
      $this->{$PACKAGE}{return}  = $args{return};
      $this->{$PACKAGE}{eval_error}  = $args{eval_error};
  
      $this->{$PACKAGE}{args}    = $args{args} || [];
      $this->{$PACKAGE}{function}= $args{function} or
                croak("$class->new() called without function arg");
  
      return $this;
  
  }
  
  1;
  
  __END__
  
  =head1 SEE ALSO
  
  L<autodie>, L<autodie::exception::system>
  
  =head1 LICENSE
  
  Copyright (C)2008 Paul Fenwick
  
  This is free software.  You may modify and/or redistribute this
  code under the same terms as Perl 5.10 itself, or, at your option,
  any later version of Perl 5.
  
  =head1 AUTHOR
  
  Paul Fenwick E<lt>pjf@perltraining.com.auE<gt>
AUTODIE_EXCEPTION

$fatpacked{"autodie/exception/system.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'AUTODIE_EXCEPTION_SYSTEM';
  package autodie::exception::system;
  use 5.008;
  use strict;
  use warnings;
  use parent 'autodie::exception';
  use Carp qw(croak);
  
  our $VERSION = '2.26'; # VERSION: Generated by DZP::OurPkg:Version
  
  # ABSTRACT: Exceptions from autodying system().
  
  my $PACKAGE = __PACKAGE__;
  
  =head1 NAME
  
  autodie::exception::system - Exceptions from autodying system().
  
  =head1 SYNOPSIS
  
      eval {
          use autodie qw(system);
  
          system($cmd, @args);
  
      };
  
      if (my $E = $@) {
          say "Ooops!  ",$E->caller," had problems: $@";
      }
  
  
  =head1 DESCRIPTION
  
  This is a L<autodie::exception> class for failures from the
  C<system> command.
  
  Presently there is no way to interrogate an C<autodie::exception::system>
  object for the command, exit status, and other information you'd expect
  such an object to hold.  The interface will be expanded to accommodate
  this in the future.
  
  =cut
  
  sub _init {
      my ($this, %args) = @_;
  
      $this->{$PACKAGE}{message} = $args{message}
          || croak "'message' arg not supplied to autodie::exception::system->new";
  
      return $this->SUPER::_init(%args);
  
  }
  
  =head2 stringify
  
  When stringified, C<autodie::exception::system> objects currently
  use the message generated by L<IPC::System::Simple>.
  
  =cut
  
  sub stringify {
  
      my ($this) = @_;
  
      return $this->{$PACKAGE}{message} . $this->add_file_and_line;
  
  }
  
  1;
  
  __END__
  
  =head1 LICENSE
  
  Copyright (C)2008 Paul Fenwick
  
  This is free software.  You may modify and/or redistribute this
  code under the same terms as Perl 5.10 itself, or, at your option,
  any later version of Perl 5.
  
  =head1 AUTHOR
  
  Paul Fenwick E<lt>pjf@perltraining.com.auE<gt>
AUTODIE_EXCEPTION_SYSTEM

$fatpacked{"autodie/hints.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'AUTODIE_HINTS';
  package autodie::hints;
  
  use strict;
  use warnings;
  
  use constant PERL58 => ( $] < 5.009 );
  
  our $VERSION = '2.26'; # VERSION: Generated by DZP::OurPkg:Version
  
  # ABSTRACT: Provide hints about user subroutines to autodie
  
  =head1 NAME
  
  autodie::hints - Provide hints about user subroutines to autodie
  
  =head1 SYNOPSIS
  
      package Your::Module;
  
      our %DOES = ( 'autodie::hints::provider' => 1 );
  
      sub AUTODIE_HINTS {
          return {
              foo => { scalar => HINTS, list => SOME_HINTS },
              bar => { scalar => HINTS, list => MORE_HINTS },
          }
      }
  
      # Later, in your main program...
  
      use Your::Module qw(foo bar);
      use autodie      qw(:default foo bar);
  
      foo();         # succeeds or dies based on scalar hints
  
      # Alternatively, hints can be set on subroutines we've
      # imported.
  
      use autodie::hints;
      use Some::Module qw(think_positive);
  
      BEGIN {
          autodie::hints->set_hints_for(
              \&think_positive,
              {
                  fail => sub { $_[0] <= 0 }
              }
          )
      }
      use autodie qw(think_positive);
  
      think_positive(...);    # Returns positive or dies.
  
  
  =head1 DESCRIPTION
  
  =head2 Introduction
  
  The L<autodie> pragma is very smart when it comes to working with
  Perl's built-in functions.  The behaviour for these functions are
  fixed, and C<autodie> knows exactly how they try to signal failure.
  
  But what about user-defined subroutines from modules?  If you use
  C<autodie> on a user-defined subroutine then it assumes the following
  behaviour to demonstrate failure:
  
  =over
  
  =item *
  
  A false value, in scalar context
  
  =item * 
  
  An empty list, in list context
  
  =item *
  
  A list containing a single undef, in list context
  
  =back
  
  All other return values (including the list of the single zero, and the
  list containing a single empty string) are considered successful.  However,
  real-world code isn't always that easy.  Perhaps the code you're working
  with returns a string containing the word "FAIL" upon failure, or a
  two element list containing C<(undef, "human error message")>.  To make
  autodie work with these sorts of subroutines, we have
  the I<hinting interface>.
  
  The hinting interface allows I<hints> to be provided to C<autodie>
  on how it should detect failure from user-defined subroutines.  While
  these I<can> be provided by the end-user of C<autodie>, they are ideally
  written into the module itself, or into a helper module or sub-class
  of C<autodie> itself.
  
  =head2 What are hints?
  
  A I<hint> is a subroutine or value that is checked against the
  return value of an autodying subroutine.  If the match returns true,
  C<autodie> considers the subroutine to have failed.
  
  If the hint provided is a subroutine, then C<autodie> will pass
  the complete return value to that subroutine.  If the hint is
  any other value, then C<autodie> will smart-match against the
  value provided.  In Perl 5.8.x there is no smart-match operator, and as such
  only subroutine hints are supported in these versions.
  
  Hints can be provided for both scalar and list contexts.  Note
  that an autodying subroutine will never see a void context, as
  C<autodie> always needs to capture the return value for examination.
  Autodying subroutines called in void context act as if they're called
  in a scalar context, but their return value is discarded after it
  has been checked.
  
  =head2 Example hints
  
  Hints may consist of scalars, array references, regular expressions and
  subroutine references.  You can specify different hints for how
  failure should be identified in scalar and list contexts.
  
  These examples apply for use in the C<AUTODIE_HINTS> subroutine and when
  calling C<autodie::hints->set_hints_for()>.
  
  The most common context-specific hints are:
  
          # Scalar failures always return undef:
              {  scalar => undef  }
  
          # Scalar failures return any false value [default expectation]:
              {  scalar => sub { ! $_[0] }  }
  
          # Scalar failures always return zero explicitly:
              {  scalar => '0'  }
  
          # List failures always return an empty list:
              {  list => []  }
  
          # List failures return () or (undef) [default expectation]:
              {  list => sub { ! @_ || @_ == 1 && !defined $_[0] }  }
  
          # List failures return () or a single false value:
              {  list => sub { ! @_ || @_ == 1 && !$_[0] }  }
  
          # List failures return (undef, "some string")
              {  list => sub { @_ == 2 && !defined $_[0] }  }
  
          # Unsuccessful foo() returns 'FAIL' or '_FAIL' in scalar context,
          #                    returns (-1) in list context...
          autodie::hints->set_hints_for(
              \&foo,
              {
                  scalar => qr/^ _? FAIL $/xms,
                  list   => [-1],
              }
          );
  
          # Unsuccessful foo() returns 0 in all contexts...
          autodie::hints->set_hints_for(
              \&foo,
              {
                  scalar => 0,
                  list   => [0],
              }
          );
  
  This "in all contexts" construction is very common, and can be
  abbreviated, using the 'fail' key.  This sets both the C<scalar>
  and C<list> hints to the same value:
  
          # Unsuccessful foo() returns 0 in all contexts...
          autodie::hints->set_hints_for(
              \&foo,
              {
                  fail => sub { @_ == 1 and defined $_[0] and $_[0] == 0 }
              }
  	);
  
          # Unsuccessful think_positive() returns negative number on failure...
          autodie::hints->set_hints_for(
              \&think_positive,
              {
                  fail => sub { $_[0] < 0 }
              }
  	);
  
          # Unsuccessful my_system() returns non-zero on failure...
          autodie::hints->set_hints_for(
              \&my_system,
              {
                  fail => sub { $_[0] != 0 }
              }
  	);
  
  =head1 Manually setting hints from within your program
  
  If you are using a module which returns something special on failure, then
  you can manually create hints for each of the desired subroutines.  Once
  the hints are specified, they are available for all files and modules loaded
  thereafter, thus you can move this work into a module and it will still
  work.
  
  	use Some::Module qw(foo bar);
  	use autodie::hints;
  
  	autodie::hints->set_hints_for(
  		\&foo,
  		{
  			scalar => SCALAR_HINT,
  			list   => LIST_HINT,
  		}
  	);
  	autodie::hints->set_hints_for(
  		\&bar,
                  { fail => SOME_HINT, }
  	);
  
  It is possible to pass either a subroutine reference (recommended) or a fully
  qualified subroutine name as the first argument.  This means you can set hints
  on modules that I<might> get loaded:
  
  	use autodie::hints;
  	autodie::hints->set_hints_for(
  		'Some::Module:bar', { fail => SCALAR_HINT, }
  	);
  
  This technique is most useful when you have a project that uses a
  lot of third-party modules.  You can define all your possible hints
  in one-place.  This can even be in a sub-class of autodie.  For
  example:
  
          package my::autodie;
  
          use parent qw(autodie);
          use autodie::hints;
  
          autodie::hints->set_hints_for(...);
  
          1;
  
  You can now C<use my::autodie>, which will work just like the standard
  C<autodie>, but is now aware of any hints that you've set.
  
  =head1 Adding hints to your module
  
  C<autodie> provides a passive interface to allow you to declare hints for
  your module.  These hints will be found and used by C<autodie> if it
  is loaded, but otherwise have no effect (or dependencies) without autodie.
  To set these, your module needs to declare that it I<does> the
  C<autodie::hints::provider> role.  This can be done by writing your
  own C<DOES> method, using a system such as C<Class::DOES> to handle
  the heavy-lifting for you, or declaring a C<%DOES> package variable
  with a C<autodie::hints::provider> key and a corresponding true value.
  
  Note that checking for a C<%DOES> hash is an C<autodie>-only
  short-cut.  Other modules do not use this mechanism for checking
  roles, although you can use the C<Class::DOES> module from the
  CPAN to allow it.
  
  In addition, you must define a C<AUTODIE_HINTS> subroutine that returns
  a hash-reference containing the hints for your subroutines:
  
          package Your::Module;
  
          # We can use the Class::DOES from the CPAN to declare adherence
          # to a role.
  
          use Class::DOES 'autodie::hints::provider' => 1;
  
          # Alternatively, we can declare the role in %DOES.  Note that
          # this is an autodie specific optimisation, although Class::DOES
          # can be used to promote this to a true role declaration.
  
          our %DOES = ( 'autodie::hints::provider' => 1 );
  
          # Finally, we must define the hints themselves.
  
  	sub AUTODIE_HINTS {
  	    return {
  	        foo => { scalar => HINTS, list => SOME_HINTS },
  	        bar => { scalar => HINTS, list => MORE_HINTS },
  	        baz => { fail => HINTS },
  	    }
  	}
  
  This allows your code to set hints without relying on C<autodie> and
  C<autodie::hints> being loaded, or even installed.  In this way your
  code can do the right thing when C<autodie> is installed, but does not
  need to depend upon it to function.
  
  =head1 Insisting on hints
  
  When a user-defined subroutine is wrapped by C<autodie>, it will
  use hints if they are available, and otherwise reverts to the
  I<default behaviour> described in the introduction of this document.
  This can be problematic if we expect a hint to exist, but (for
  whatever reason) it has not been loaded.
  
  We can ask autodie to I<insist> that a hint be used by prefixing
  an exclamation mark to the start of the subroutine name.  A lone
  exclamation mark indicates that I<all> subroutines after it must
  have hints declared.
  
  	# foo() and bar() must have their hints defined
  	use autodie qw( !foo !bar baz );
  
  	# Everything must have hints (recommended).
  	use autodie qw( ! foo bar baz );
  
  	# bar() and baz() must have their hints defined
  	use autodie qw( foo ! bar baz );
  
          # Enable autodie for all of Perl's supported built-ins,
          # as well as for foo(), bar() and baz().  Everything must
          # have hints.
          use autodie qw( ! :all foo bar baz );
  
  If hints are not available for the specified subroutines, this will cause a
  compile-time error.  Insisting on hints for Perl's built-in functions
  (eg, C<open> and C<close>) is always successful.
  
  Insisting on hints is I<strongly> recommended.
  
  =cut
  
  # TODO: implement regular expression hints
  
  use constant UNDEF_ONLY       => sub { not defined $_[0] };
  use constant EMPTY_OR_UNDEF   => sub {
      ! @_ or
      @_==1 && !defined $_[0]
  };
  
  use constant EMPTY_ONLY     => sub { @_ == 0 };
  use constant EMPTY_OR_FALSE => sub {
      ! @_ or
      @_==1 && !$_[0]
  };
  
  use constant SINGLE_TRUE => sub { @_ == 1 and not $_[0] };
  
  use constant DEFAULT_HINTS => {
      scalar => UNDEF_ONLY,
      list   => EMPTY_OR_UNDEF,
  };
  
  
  use constant HINTS_PROVIDER => 'autodie::hints::provider';
  
  our $DEBUG = 0;
  
  # Only ( undef ) is a strange but possible situation for very
  # badly written code.  It's not supported yet.
  
  my %Hints = (
      'File::Copy::copy' => { scalar => SINGLE_TRUE, list => SINGLE_TRUE },
      'File::Copy::move' => { scalar => SINGLE_TRUE, list => SINGLE_TRUE },
      'File::Copy::cp'   => { scalar => SINGLE_TRUE, list => SINGLE_TRUE },
      'File::Copy::mv'   => { scalar => SINGLE_TRUE, list => SINGLE_TRUE },
  );
  
  # Start by using Sub::Identify if it exists on this system.
  
  eval { require Sub::Identify; Sub::Identify->import('get_code_info'); };
  
  # If it doesn't exist, we'll define our own.  This code is directly
  # taken from Rafael Garcia's Sub::Identify 0.04, used under the same
  # license as Perl itself.
  
  if ($@) {
      require B;
  
      no warnings 'once';
  
      *get_code_info = sub ($) {
  
          my ($coderef) = @_;
          ref $coderef or return;
          my $cv = B::svref_2object($coderef);
          $cv->isa('B::CV') or return;
          # bail out if GV is undefined
          $cv->GV->isa('B::SPECIAL') and return;
  
          return ($cv->GV->STASH->NAME, $cv->GV->NAME);
      };
  
  }
  
  sub sub_fullname {
      return join( '::', get_code_info( $_[1] ) );
  }
  
  my %Hints_loaded = ();
  
  sub load_hints {
      my ($class, $sub) = @_;
  
      my ($package) = ( $sub =~ /(.*)::/ );
  
      if (not defined $package) {
          require Carp;
          Carp::croak(
              "Internal error in autodie::hints::load_hints - no package found.
          ");
      }
  
      # Do nothing if we've already tried to load hints for
      # this package.
      return if $Hints_loaded{$package}++;
  
      my $hints_available = 0;
  
      {
          no strict 'refs';   ## no critic
  
          if ($package->can('DOES') and $package->DOES(HINTS_PROVIDER) ) {
              $hints_available = 1;
          }
          elsif ( PERL58 and $package->isa(HINTS_PROVIDER) ) {
              $hints_available = 1;
          }
          elsif ( ${"${package}::DOES"}{HINTS_PROVIDER.""} ) {
              $hints_available = 1;
          }
      }
  
      return if not $hints_available;
  
      my %package_hints = %{ $package->AUTODIE_HINTS };
  
      foreach my $sub (keys %package_hints) {
  
          my $hint = $package_hints{$sub};
  
          # Ensure we have a package name.
          $sub = "${package}::$sub" if $sub !~ /::/;
  
          # TODO - Currently we don't check for conflicts, should we?
          $Hints{$sub} = $hint;
  
          $class->normalise_hints(\%Hints, $sub);
      }
  
      return;
  
  }
  
  sub normalise_hints {
      my ($class, $hints, $sub) = @_;
  
      if ( exists $hints->{$sub}->{fail} ) {
  
          if ( exists $hints->{$sub}->{scalar} or
               exists $hints->{$sub}->{list}
          ) {
              # TODO: Turn into a proper diagnostic.
              require Carp;
              local $Carp::CarpLevel = 1;
              Carp::croak("fail hints cannot be provided with either scalar or list hints for $sub");
          }
  
          # Set our scalar and list hints.
  
          $hints->{$sub}->{scalar} = 
          $hints->{$sub}->{list} = delete $hints->{$sub}->{fail};
  
          return;
  
      }
  
      # Check to make sure all our hints exist.
  
      foreach my $hint (qw(scalar list)) {
          if ( not exists $hints->{$sub}->{$hint} ) {
              # TODO: Turn into a proper diagnostic.
              require Carp;
              local $Carp::CarpLevel = 1;
              Carp::croak("$hint hint missing for $sub");
          }
      }
  
      return;
  }
  
  sub get_hints_for {
      my ($class, $sub) = @_;
  
      my $subname = $class->sub_fullname( $sub );
  
      # If we have hints loaded for a sub, then return them.
  
      if ( exists $Hints{ $subname } ) {
          return $Hints{ $subname };
      }
  
      # If not, we try to load them...
  
      $class->load_hints( $subname );
  
      # ...and try again!
  
      if ( exists $Hints{ $subname } ) {
          return $Hints{ $subname };
      }
  
      # It's the caller's responsibility to use defaults if desired.
      # This allows on autodie to insist on hints if needed.
  
      return;
  
  }
  
  sub set_hints_for {
      my ($class, $sub, $hints) = @_;
  
      if (ref $sub) {
          $sub = $class->sub_fullname( $sub );
  
          require Carp;
  
          $sub or Carp::croak("Attempts to set_hints_for unidentifiable subroutine");
      }
  
      if ($DEBUG) {
          warn "autodie::hints: Setting $sub to hints: $hints\n";
      }
  
      $Hints{ $sub } = $hints;
  
      $class->normalise_hints(\%Hints, $sub);
  
      return;
  }
  
  1;
  
  __END__
  
  
  =head1 Diagnostics
  
  =over 4
  
  =item Attempts to set_hints_for unidentifiable subroutine
  
  You've called C<< autodie::hints->set_hints_for() >> using a subroutine
  reference, but that reference could not be resolved back to a
  subroutine name.  It may be an anonymous subroutine (which can't
  be made autodying), or may lack a name for other reasons.
  
  If you receive this error with a subroutine that has a real name,
  then you may have found a bug in autodie.  See L<autodie/BUGS>
  for how to report this.
  
  =item fail hints cannot be provided with either scalar or list hints for %s
  
  When defining hints, you can either supply both C<list> and
  C<scalar> keywords, I<or> you can provide a single C<fail> keyword.
  You can't mix and match them.
  
  =item %s hint missing for %s
  
  You've provided either a C<scalar> hint without supplying
  a C<list> hint, or vice-versa.  You I<must> supply both C<scalar>
  and C<list> hints, I<or> a single C<fail> hint.
  
  =back
  
  =head1 ACKNOWLEDGEMENTS
  
  =over 
  
  =item *
  
  Dr Damian Conway for suggesting the hinting interface and providing the
  example usage.
  
  =item *
  
  Jacinta Richardson for translating much of my ideas into this
  documentation.
  
  =back
  
  =head1 AUTHOR
  
  Copyright 2009, Paul Fenwick E<lt>pjf@perltraining.com.auE<gt>
  
  =head1 LICENSE
  
  This module is free software.  You may distribute it under the
  same terms as Perl itself.
  
  =head1 SEE ALSO
  
  L<autodie>, L<Class::DOES>
  
  =for Pod::Coverage get_hints_for load_hints normalise_hints sub_fullname get_code_info
  
  =cut
AUTODIE_HINTS

$fatpacked{"autodie/skip.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'AUTODIE_SKIP';
  package autodie::skip;
  use strict;
  use warnings;
  
  our $VERSION = '2.26'; # VERSION
  
  # This package exists purely so people can inherit from it,
  # which isn't at all how roles are supposed to work, but it's
  # how people will use them anyway.
  
  if ($] < 5.010) {
      # Older Perls don't have a native ->DOES.  Let's provide a cheap
      # imitation here.
  
      *DOES = sub { return shift->isa(@_); };
  }
  
  1;
  
  __END__
  
  =head1 NAME
  
  autodie::skip - Skip a package when throwing autodie exceptions
  
  =head1 SYNPOSIS
  
      use parent qw(autodie::skip);
  
  =head1 DESCRIPTION
  
  This dummy class exists to signal that the class inheriting it should
  be skipped when reporting exceptions from autodie.  This is useful
  for utility classes like L<Path::Tiny> that wish to report the location
  of where they were called on failure.
  
  If your class has a better way of doing roles, then you should not
  load this class and instead simply say that your class I<DOES>
  C<autodie::skip> instead.
  
  =head1 AUTHOR
  
  Copyright 2013, Paul Fenwick <pjf@cpan.org>
  
  =head1 LICENSE
  
  This module is free software. You may distribute it under the same
  terms as Perl itself.
  
  =head1 SEE ALSO
  
  L<autodie>, L<autodie::exception>
  
  =for Pod::Coverage DOES
  
  =cut
AUTODIE_SKIP

s/^  //mg for values %fatpacked;

my $class = 'FatPacked::'.(0+\%fatpacked);
no strict 'refs';
*{"${class}::files"} = sub { keys %{$_[0]} };

if ($] < 5.008) {
  *{"${class}::INC"} = sub {
     if (my $fat = $_[0]{$_[1]}) {
       return sub {
         return 0 unless length $fat;
         $fat =~ s/^([^\n]*\n?)//;
         $_ = $1;
         return 1;
       };
     }
     return;
  };
}

else {
  *{"${class}::INC"} = sub {
    if (my $fat = $_[0]{$_[1]}) {
      open my $fh, '<', \$fat
        or die "FatPacker error loading $_[1] (could be a perl installation issue?)";
      return $fh;
    }
    return;
  };
}

unshift @INC, bless \%fatpacked, $class;
  } # END OF FATPACK CODE


use FindBin qw/$Bin/;
use local::lib "$Bin/local/";
use Modern::Perl '2015';
use experimental qw/signatures/;
use autodie;
use Parallel::ForkManager;
use Pod::Usage;
use Getopt::Lucid qw/:all/;

my @specs = (
    Param("megan|m")->default($ENV{'HOME'}."/local/bin/MEGAN"),
    Param("meganLicense|m")->default($ENV{'HOME'}."/MEGAN5-academic-license.txt"),
    Switch("format|f")->default(0),
    Param("outputDIR|o")->default(""),
    Param("contigs|c"),
    Param("refseqKO|r")->default("/export2/home/uesu/db/konr/"),
    Param("threads|t")->default(1),
    Param("prefix|p"),
    Switch("help|h"),
    Param("windowSize|w")->default(200)
);

my $opt = Getopt::Lucid->getopt( \@specs )->validate;
pod2usage(-verbose=>2) if $opt->get_help;
$opt->validate({'requires' => ['format','refseqKO','outputDIR','contigs']});

my $outputDir     = $opt->get_outputDIR;
my $refseqProtDB  = $opt->get_refseqKO;
my $MAX_PROCESSES = $opt->get_threads;
my $toFormat      = $opt->get_format;
my $contigDir     = $opt->get_contigs;
my $meganPath     = $opt->get_megan;
my $meganLicense  = $opt->get_meganLicense;
system "mkdir $outputDir";

say "## Using $MAX_PROCESSES threads";

say "## Blasting"; ##################################################
system "script/pAss.00.blast.pl --threads $MAX_PROCESSES --kodb $refseqProtDB --output $outputDir/pAss00 --format $toFormat --contigs $contigDir";

say "MEGAN aln"; ##################################################
my $pm0 = Parallel::ForkManager->new($MAX_PROCESSES);
foreach my $ko (`ls $outputDir/pAss00/ | sed s/\.blastx//`)
{   chomp $ko;
    $pm0->start and next;
    say "Processing $ko";
    system "mkdir -p $outputDir/pAss01/$ko";
    system "script/pAss.01.msa.pl --queryFasta $contigDir/$ko/454AllContigs.fna --blastFile $outputDir/pAss00/$ko.blastx --megan $meganPath --meganLicense --output $outputDir/pAss01/$ko";
    $pm0->finish;
}
$pm0->wait_all_children;

say "## Generating MSA"; ##################################################
my $pm = Parallel::ForkManager->new($MAX_PROCESSES);
foreach my $ko (`ls $outputDir/pAss01/ | grep -v log`) #need to change this; this is hard coded
{   chomp $ko;
    $pm->start and next;
    system "script/pAss.03.master.msa.pl --refseqFasta $refseqProtDB/ko:$ko --msadir $outputDir/pAss01/$ko --out $outputDir/pAss03 --ko $ko";
    $pm->finish;
}
$pm->wait_all_children;


say "## MSA Diagnostics"; #################################################
system "mkdir $outputDir/pAss04";
system "mkdir $outputDir/pAss10";

my $pm3 = Parallel::ForkManager->new($MAX_PROCESSES);
foreach my $ko (`ls $outputDir/pAss03/ | grep -v temp | sed s/\.msa//g`)
{
    chomp $ko;
    $pm3->start and next;
    system "script/pAss.04.msa2group.pl --msa $outputDir/pAss03/$ko.msa --outputPrefix $outputDir/pAss04/$ko";
    system "script/pAss.10.maxDiversity.pl --minLength 200 --inputFile $outputDir/pAss03/$ko.msa --outputDir $outputDir/pAss10/$ko";
    $pm3->finish;
}
$pm3->wait_all_children;

say "## Output MaxDiveristy Region";
system "mkdir $outputDir/pAss11";
my $pm4 = Parallel::ForkManager->new($MAX_PROCESSES);
foreach my $ko (`ls $outputDir/pAss10/`)
{
    chomp $ko;
    $pm4->start and next;
    system "script/pAss.11.best.window.r $outputDir/pAss10/$ko/$ko $outputDir/pAss03/$ko.msa $outputDir/pAss11/";
    $pm4->finish;
}
$pm4->wait_all_children;

#Documentation
=pod

=head1 NAME

    maxDiversity

=head1 DESCRIPTION

    Before running maxDiversity the following is required

=over 4

=item Protein Reference Sequences

    Prokaryotic sequences only,  grouped by KOs (eg. K00001.fa, K00002.fa)

=item Contigs

    Contigs should be in found in a root directory separated by KO ids (NEWBLER)

    root/directory
    |-- K00001
    |   |-- 454AllContigs.fna
    |   |-- 454AllContigs.qual
    |   |-- 454ContigGraph.txt
    |   |-- ...
    |   `-- sff
    |-- K00002
    |   |-- 454AllContigs.fna
    |   |-- 454AllContigs.qual
    |   |-- 454ContigGraph.txt
    |   |-- ...
    |   `-- sff

=back

=head1 OPTIONS

=over 4

=item --megan -m

    File path pointing to MEGAN executable. Defaults to $HOME/loca/bin/MEGAN

=item --meganLicense

    File Path poining to the MEGAN5 academic license

=item --contigs, -c

    the path to dir containing contigs fna files

        data/contigs/
        |-- K00001
        |   `-- 454AllContigs.fna
        |-- K00002
        |   `-- 454AllContigs.fna
        |-- K00003
        |   `-- 454AllContigs.fna
        |-- K00004
        |   `-- 454AllContigs.fna
        |-- K00005
        |   `-- 454AllContigs.fna
        |-- K00007
        |   `-- 454AllContigs.fna
        |-- K00008
        |   `-- 454AllContigs.fna
        |-- K00009
        |   `-- 454AllContigs.fna
        |-- K00010
        |   `-- 454AllContigs.fna
        `-- K00011
            `-- 454AllContigs.fna`

=item --format, -f

    Switch for running formatdb / makeblastdb (for times when you need to rerun the pipeline and do not wish to rerun this step)

=item --refseqKO, -r

    the prefix to which to append the KO id eg. /export2/home/uesu/db/konr/ko:

    note the reference sequence files should be named in the same convention as seen in the example

=item --threads, -t

    the number of threads to use

=item --prefix, -p

    the location for all the intermediate files

=item --windowSize -w

    the size of the window when looking for a maxDiversity region

=item --help

    throws up the help message

=back

=cut
